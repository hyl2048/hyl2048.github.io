<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="On Java 8, huang"><meta name="description" content=""><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><script async src="https://www.googletagmanager.com/gtag/js?id="></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","")</script><title>On Java 8 | huang</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/libs/awesome/css/all.css"><link rel="stylesheet" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/libs/aos/aos.css"><link rel="stylesheet" href="/libs/animate/animate.min.css"><link rel="stylesheet" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/css/matery.css"><link rel="stylesheet" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="huang" type="application/atom+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">huang</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">huang</div><div class="logo-desc">Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/hyl2048" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/hyl2048" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/21.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">On Java 8</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px}#toc-content .is-active-link{color:#42b983}#toc-content .is-active-link::before{background-color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><span class="chip bg-color">无标签</span></div></div><div class="col s5 right-align"></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2020-07-24</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h2><p>​ 把万物看作对象，对象之间在传递信息。</p><p>​ 对象的创建，对象的存储（数量、类型），对象之间的关系处理（对象间传递信息），对象的销毁，异常处理</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>​ Java 为单继承语言，有别于多继承的C++</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>​ 多样式与向上转型</p><p>​ 多态和构造器</p><p>​ <strong>多态的好处</strong>在于解耦</p><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>​ 组合和继承</p><p>​ 构造器加载顺序（对比销毁顺序）</p><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>​ 接口为抽象类</p><p>​ 接口被用来建立类之间的协议</p><p>​ 接口中的守卫方法或虚拟扩展方法（default）</p><p>​ 类可以实现多个接口，但是抽象类只能继承单一抽象类</p><p>​ 面向接口编程，将接口与实现解耦可以应用于多种不同的实现</p><p>​ 选择问题：</p><p>​ 尽可能地抽象，更倾向使用接口而非抽象类</p><p>​ 接口和策略模式</p><p>​ 接口和工厂模式</p><p>​ 优先使用类而不是接口，若有必要使用接口，再对代码重构也不迟。如果只是单纯为了设计接口而设计接口，只会徒增复杂性。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>​ 内部自动类拥有对外部类所有成员的访问权，外部类与内部类产生的引用</p><p>​ 匿名内部类，与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备，而如果是实现接口，也只能实现一个接口。</p><p>​ 嵌套类</p><p>​ <strong>内部类有效地实现了多重继承</strong>，每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实习，对于内部类都没有影响</p><p>​ 内部类的其他特性：</p><p>​ 内部类可以有多个实例</p><p>​ 再单个外部类中，可以让多个内部类以不同的方 式实现</p><p>​ 创建内部类对象的时刻并不依赖于外部类对象的 创建</p><p>​ 内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体</p><p>​ 内部类提供的闭包功能，相比指针更灵活更安全</p><p>​ 回调的价值在于它的灵活性-可以再运行时动态地决定需要调用什么方法</p><p>​ 在控制框架使用内部类的价值</p><p>​ 局部内部类和匿名内部类</p><p>设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>​ <strong>持有对象</strong>的思想</p><p>​ 泛型与类型安全的集合</p><p>​ 散列码和hashCode()</p><p>​ List可以在创建后添加或删除元素，并自行调整大小</p><p>​ collection</p><p>​ 迭代器，能够将遍历序列的操作与该序列的底层结构分离</p><p>​ for-in 和迭代器</p><p>​ 集合和迭代器</p><p>​ <img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Ccollection.png" alt="collection"></p><p>​</p><p>​ 上图中用粗黑的框包裹的类为常用的类</p><p><img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Ccollection1.png" alt="collection1"></p><p><img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Cmap.png" alt="map"></p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>​ lambda表达式</p><p>​ 方法引用</p><p>​ 函数式接口：</p><p>​ 在使用函数式接口时，名称无关紧要，只要参数类型和返回类型相同</p><p>​ 高阶函数</p><p>​ 闭包，利用闭包可以轻松生成函数。支持闭包也叫变量捕获。只要有内部类就会有闭包</p><p>​ 等同final效果</p><p>​ 函数组合，多个还能输组合成新函数</p><p>​ 柯里化和部分求值</p><p>​ 柯里化，将一个多参数函数转换为一系列单参数函数</p><p>​ 纯函数式编程，Scala，Clojure</p><h2 id="流式编程"><a href="#流式编程" class="headerlink" title="流式编程"></a>流式编程</h2><p>​ 集合优化了对象的存储，而流和对象有关。流是一系列与特定存储机制无关的元素。利用流，可以不迭代集合中的元素，就可以提取和操作数据。<strong>流的好处是，它使得程序更加短小和容易理解</strong>。</p><p>​ Lambda表达式和方法引用结合流式编程会更加简便、简洁。</p><p>​ 流式编程是一种声明式编程，声明要做什么，而非怎么做的编程风格。</p><p>​ 流式编程采用内部迭代。</p><p>​ 流是懒加载的。</p><p>​ 流操作，创建流，修该流元素，消费流元素</p><p>​ 创建流：</p><p>​ stream.of(); stream(); 集合通过stream()方法来产生一个流。</p><p>​ 中级流操作</p><p>​ optional类</p><p>​ 终端操作</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>​ 异常处理程序，不仅能节省代码，而且把“描述在正常执行剁成中做什么事”和“出了问题怎么办”的代码相分离。异常机制使代码的阅读、编写和调试工作更加井井有条。</p><p>​ 基本异常</p><p>​ 异常捕获</p><p>​ 自定义异常</p><p>​ 异常声明</p><p>​ 重新抛出异常</p><p>​ 异常链</p><p>​ Java标准异常</p><p>​ finally 用于把除内存之外的资源恢复到他们初始状态时。如果把finally子句和带标签的break及continue配合使用，在Java里就没必要使用goto语句了</p><p>​ 异常丢失</p><p>​ 异常限制</p><p>​ 构造器和异常处理</p><p>​ Try-With-Resources和构造器异常处理</p><p>​ 异常匹配</p><p>​ 异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。异常处理的一个中哟啊目标就是把错误处理的代码同错误发生的地点相分离。</p><p>​ <strong>吞了异常</strong></p><p>​ 被检查的异常与并发症</p><p>​ 所有模型都是错误的，但有些是 能用的。</p><p>​ 反射和泛型就是用来补偿静态类型检查所带来的过多限制。</p><p>​ 好的程序设计语言能帮助程序员写出好程序，但无论哪种语言都避免不了程序员用它写出坏程序。</p><p>​ 把被检查的异常转换为不检查的异常</p><p>​ 异常链</p><p>​ 用RuntimeException来包装，被检查的异常</p><p>​ 异常指南</p><p>​ 1.尽可能使用 try-with-resource。</p><p>​ 2.在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）</p><p>​ 3.解决问题并且重新调用产生异常的方法。</p><p>​ 4.进行少许修补，然后绕过异常发生的地方继续执行。</p><p>​ 5.用别的数据进行计算，以代替方法预计会返回的值。</p><p>​ 6.把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</p><p>​ 7.把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</p><p>​ 8.终止程序。</p><p>​ 9.进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。）</p><p>​ 10.让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）</p><p>​ 报告功能是异常的精髓所在</p><h2 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h2><p>让代码健壮的方法</p><p>​ 测试</p><p>​ 单元测试</p><p>​ 前置条件（契约式设计DBC）</p><p>​ 断言</p><p>​ Java断言语法</p><p>​ Guava断言</p><p>​ 检查指令</p><p>​ 测试驱动开发（TDD）</p><p>​ 日志</p><p>​ 调试</p><p>​ JDB、图形化调试器</p><p>​ 基准测试</p><p>​ 剖析和优化</p><p>​ 剖析和优化</p><p>​ 优化准则</p><p>​ 避免为了性能牺牲代码的可读性。</p><p>​ 不要独立地看待性能。衡量与带来的收益相 比所需投入的工作量。</p><p>​ 程序的大小很重要。性能优化通常只对运行 了长时间的大型项目有价值。性能通常不是小项 目的关注点。</p><p>​ 运行起来程序比一心钻研它的性能具有更高 的优先级。一旦你已经有了可工作的程序，如有 必要的话，你可以使用剖析器提高它的效率。只 有当性能是关键因素时，才需要在设计/开发阶段 考虑性能。</p><p>​ 不要猜测瓶颈发生在哪。运行剖析器，让剖 析器告诉你。</p><p>​ 无论何时有可能的话，显式地设置实例为 null 表明你不再用它。这对垃圾收集器来说是个 有用的暗示。</p><p>​ <strong>static final</strong> 修饰的变量会被 JVM 优化从而 提高程序的运行速度。因而程序中的常量应该声 明 <strong>static final</strong>。</p><p>​ 风格检测</p><p>​ 静态错误分析</p><p>​ 代码重审</p><p>​ 结对编程</p><p>​ 重构：</p><p>​ 重构基石：</p><p>​ 测试</p><p>​ 自动构建</p><p>​ 版本控制</p><p>​ 持续集成</p><p>​ 持续集成服务器</p><p>​ 持续集成需要分布式版本管理，自动构建和自动 测测试系统作为基础</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>​ 流与文件结合使得文件操作编程变得更加优雅</p><p>​ 文件和目录路径</p><p>​ 选取部分路径片段</p><p>​ 路径分析</p><p>​ FIile工具类</p><p>​ 文件系统</p><p>​ 路径监听</p><p>​ 文件删除和线程</p><p>​ 文件查找</p><p>​ 文件读写</p><p>​</p><p>​ java.nio.file</p><p>​ java.nio.file.Files</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>​ 字符串的不可变</p><p>​ 参数是为该方法提供信息的，而不是想让该方法 改变自己的</p><p>​ +的重载与StringBuilder</p><p>​ 不可变性与效率，string与stringbuilder类</p><p>​ 在有循环且有性能问题时，使用stringbuilder类</p><p>​ stringbuffer与stringbuilder，stringbuffer是线 程安全的，因此开销会大一些。</p><p>​ 意外递归</p><p>​ 打印对象内存地址，使用super.tostring()，而不 去使用this, 使用this会发生自动类型转换、递归调用</p><p>​ 字符串操作</p><p>​ 当需要改变字符串的内容时，<code>String</code> 类的方法 都会返回一个新的 <code>String</code> 对象。同时，如果内容不 改变，<code>String</code> 方法只是返回原始对象的一个引用而 已。这可以节约存储空间以及避免额外的开销</p><p>​ 在 Java 中，字符串操作还主要集中于<code>String</code>、 <code>StringBuffer</code> 和 <code>StringTokenizer</code> 类</p><p>​ 格式化输出</p><p>​ printf()</p><p>​ System.out.format()</p><p>​ Formatter类，</p><p>​ 在 Java 中，所有的格式化功能都是由 <code>java.util.Formatter</code> 类处理的。</p><p>​ 格式化修饰符</p><p>​ <code>Formatter</code> 转换</p><p>​ 还有许多不常用的类型转换与格式修饰符选 项，你可以在 JDK 文档中的 <code>Formatter</code> 类部分 找到它们。</p><p>​ String.format()</p><p>​ 在 <code>String.format()</code> 内部，它也是创建了 一个 <code>Formatter</code> 对象，然后将你传入的参数转 给 <code>Formatter</code>。不过，与其自己做这些事情，不 如使用便捷的 <code>String.format()</code> 方法，何况这 样的代码更清晰易读。</p><p>​ 一个十六进制转储（dump）工具</p><p>​ 为了打开及读入二进制文件，我们用到了另一个 工具 <code>Files.readAllBytes()</code>，这已经在 <a href="">Files章节</a> 介绍过了。这里的 <code>readAllBytes()</code> 方法将整个文件 以 <code>byte</code> 数组的形式返回</p><p>​ 正则表达式</p><p>​ 处理string的匹配、选择、编辑以及验证</p><p>​ <code>String.split()</code> 还有一个重载的版本，它允许 你限制字符串分割的次数</p><p>​ 创建正则表达式</p><p>​ 正则表达式的完整构造子列表，请参考JDK文档 <code>java.util.regex</code> 包中的 <code>Pattern</code>类</p><p>​ 当你学会了使用字符类（character classes）之 后，正则表达式的威力才能真正显现出来</p><p>​ 量词</p><p>​ 量词描述了一个模式捕获输入文本的方式</p><p>​ CharSequence</p><p>​ 接口 <code>CharSequence</code> 从 <code>CharBuffer</code>、 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 类中抽象 出了字符序列的一般化定义</p><p>​ Pattern<code>和</code>Matcher</p><p>​ java.util.regext.Matcher</p><p>​ <code>find()</code></p><p>​ <code>Matcher.find()</code> 方法可用来在 <code>CharSequence</code> 中查找多个匹配</p><p>​ start()<code>和</code>end()</p><p>​ <code>Pattern</code> 标记</p><p>​ split()</p><p>​ 替换操作</p><p>​ reset()</p><p>​ 正则表达式与 Java I/O</p><p>​ 扫描输入</p><p>​ <code>Scanner</code> 分隔符</p><p>​ StringTokenizer类</p><p>​ 在 Java 引入正则表达式（J2SE1.4）和 <code>Scanner</code> 类（Java SE5）之前，分割字符 串的唯一方法是使用 <code>StringTokenizer</code> 来 分词。不过，现在有了正则表达式和 <code>Scanner</code>，我们可以使用更加简单、更加简洁 的方式来完成同样的工作了</p><p>​ 基本上，我们可以放心地说， <code>StringTokenizer</code> 已经可以废弃不用了。</p><h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p>​ java如何在运行时识别对象和类信息：</p><p>​ “传统的”RTTI（运行时类型信息）</p><p>​ 使用 RTTI，我们可以查询某个 <code>Shape</code> 引用所指向对象的确切类型， 然后择或者剔除特例。</p><p>​ “反射”机制：允许我们在运行时发现和 使用类信息。</p><p>​ <code>Class</code> 对象</p><p>​ 类加载器</p><p>​ 原生类加载器与额外的类加载器</p><p>​ <code>Class</code> 对象仅在需要的时候才会被 加载，<code>static</code> 初始化是在类加载时进 行的</p><p>​ 无论何时，只要你想在运行时使用 类型信息，就必须先得到那个 <code>Class</code> 对 象的引 用。<code>Class.forName()</code> 就是 实现这个功能的一个便捷途径，因为使 用该方法你不需要先持有这个类型 的对 象。但是，如果你已经拥有了目标类的 对象，那就可以通过调用 <code>getClass()</code> 方法来获取 <code>Class</code> 引用了，这个方法来 自根类 <code>Object</code>，它将返回表示该对象 实际类型的 <code>Class</code> 对象的引用</p><p>​ <code>Class</code> 对象的 <code>newInstance()</code> 方 法是实现“虚拟构造器”的一种途径，虚 拟构造器可以让你在不知道一个类的确 切类型的时候，创建这个类的对象</p><p>​ 类字面常量</p><p>​ 类字面常量用于生成类对象的引用</p><p>​ 为了使用类而做的准备工作实际包含三 个步骤</p><p>​ 加载：这是由类加载器执行的。该步骤 将查找字节码（通常在 classpath 所指定的 路径中查找，但这并非是必须的），并从这 些字节码中创建一个 <code>Class</code> 对象</p><p>​ 链接：在链接阶段将验证类中的字节 码，为 <code>static</code> 字段分配存储空间，并且如 果需要的话，将解析这个类创建的对其他类 的所有引用。</p><p>​ 初始化：如果该类具有超类，则先初始 化超类，执行 <code>static</code> 初始化器和 <code>static</code> 初始化块。</p><p>​ 仅使用 <code>.class</code> 语法来获得对类对象的 引用不会引发初始化。但与此相反，使用 <code>Class.forName()</code> 来产生 <code>Class</code> 引用会 立即就进行初始化</p><p>​ 泛化的 <code>Class</code> 引用</p><p>​ 向 <code>Class</code> 引用添加泛型语法的原因只是 为了提供编译期类型检查</p><p>​ <code>cast()</code> 方法</p><p>​ Java 中用于 <code>Class</code> 引用的转型语 法</p><p>​ 类型转换检测</p><p>​ 已知的 RTTI 类型</p><p>​ 传统的类型转换，如 “<code>(Shape)</code>”， 由 RTTI 确保转换的正确性，如果执行了 一个 错误的类型转换，就会抛出一 个 <code>ClassCastException</code> 异常。</p><p>​ 代表对象类型的 <code>Class</code> 对象. 通过 查询 <code>Class</code> 对象可以获取运行时所需的 信息.</p><p>​ RTTI 在 Java 中还有第三种形式，那就 是关键字 <code>instanceof</code></p><p>​ 使用类字面量</p><p>​ 使用类字面量重新实现 <code>PetCreator</code> 类的话，其结果在 很多方面都会更清晰。</p><p>​ 一个动态 <code>instanceof</code> 函数</p><p>​ <code>Class.isInstance()</code> 方法提供 了一种动态测试对象类型的方法。</p><p>​ <code>isInstance()</code> 方法消除了对 <code>instanceof</code> 表达式的需要</p><p>​ 递归计数</p><p>​ 可以使用 <code>Class.isAssignableFrom()</code> 而不是预加载 <code>Map</code> ，并创建一个不限于计数 <code>Pet</code> 的通用工具</p><p>​ 注册工厂</p><p>​</p><p>​ 类的等价比较</p><p>​ 查询类型信息时，需要注意： instanceof 的形式(即 <code>instanceof</code> 或 <code>isInstance()</code> ，这两者产生的结果相同) 和与 Class 对象直接比较这两者间存在重要区别</p><p>​ <code>instanceof</code> 说的是“你是这个类，还是从这个类派生的类？”。而如果使用 <code>==</code> 比较实际的<code>Class</code> 对象，则与继承无关 —— 它要么是确切的类型，要么不是。</p><p>​ 反射：运行时类信息</p><p>​ 如果你不知道对象的确切类型，RTTI 会告 诉你。但是，有一个限制：必须在编 译时 知道类型，才能使用 RTTI 检测它，并对信息做 一些有用的事情。换句话说，编译器必须知道你 使用的所有类</p><p>​ 反射提供了检测可用方法并生成方法名称 的机制</p><p>​ 在运行时发现类信息的另一个令人信服的 动机是提供跨网络在远程平台上创建和执行对象 的能力。这称为<em>远程方法调用</em>（RMI），它使 Java 程序的对象分布在许多机器上</p><p>​ 重要的是要意识到反射没有什么魔力。当 你使用反射与未知类型的对象交互时，JVM 将查 看该对象，并看到它属于特定的类（就像普通的 RTTI）。在对其执行任何操作之前，必须加载 <code>Class</code> 对象。因此，该特定类型的 <code>.class</code> 文件必须在本地计算机上或通过网络对 JVM 仍 然可用。因此，RTTI 和反射的真正区别在于， 使用 RTTI 时，编译器在编译时会打开并检查 .class文件。换句话说，你可以用“正常”的方式 调用一个对象的所有方法。通过反射，.class文 件在编译时不可用；它由运行时环境 打开 并检查。</p><p>​ 类方法提取器</p><p>​ 反射是用来支持其他java特性的，如对象序 列化、动态提取有关类的信息</p><p>​ 编程时，当你不记得某个类是否有特定的 方法，并且不想在 JDK 文档中搜索索引或类层 次结构时，或者如果你不知道该类是否可以对 <code>Color</code> 对象执行任何操作时，该工具能节省不 少时间</p><p>​ 动态代理</p><p>​ 当你希望将额外的操作与“真实对象”做分离 时，代理可能会有所帮助，尤 其是当你想要轻松 地启用额外的操作时，反之亦然（设计模式就是 封装 变更—所以你必须改变一些东西以证明模 式的合理性）。例如，如果你想跟踪 RealObject中方法的调用，或衡量此类调用的开销，该怎么 办？你不想这部分 代码耦合到你的程序中，而代理能使你可以很轻松地添加或删除它</p><p>​ Java 的<em>动态代理</em>更进一步，不仅动态创建代理对 象而且动态处理对代理方法的调用。在动态代理上进行 的所有调用都被重定向到单个<em>调用处理程序</em>，该处理程 序负责发现调用的内容并决定如何处理</p><p>​ 可以通过调用静态方法Proxy.newProxyInstance()来创建动态代理，该方法需要一个类加载器（通常可以从已加载的对象中获取）</p><p>​ 通常执行代理操作，然后使用 <code>Method.invoke()</code> 将请求转发给被代理对象，并携带必要的参数。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是，可以过滤某些方法调用，同时传递其他方法调用：</p><p>​ Optional类</p><p>​ 如果你使用内置的 <code>null</code> 来表示没有对象，每次 使用引用的时候就必须测试一下引用是否为 <code>null</code>，这 显得有点枯燥，而且势必会产生相当乏味的代码。问题 在于 <code>null</code> 没什么自己的行为，只会在你想用它执行 任何操作的时候产生 <code>NullPointException</code>。 <code>java.util.Optional</code>（首次出现是在<a href="https://github.com/LingCoder/OnJava8/tree/5d7462a629a410cb29f98938387daa0d846d8e4b/docs/book/docs/book/13-Functional-Programming.md">函数式编程</a>这 章）为 <code>null</code> 值提供了一个轻量级代理，<code>Optional</code> 对象可以防止你的代码直接抛出NullPointException。</p><p>​ 标记接口</p><p>​ 有时候使用一个<strong>标记接口</strong>来表示空值会更方便。标记接口里边什么都没有，你只要把它的名字当做标签来用就可以。</p><p>​ 假设存在许多不同类型的 <code>Robot</code>，我们想让每种 <code>Robot</code> 都创建一个 <code>Null</code> 对象来执行一些特殊的操作——在本例中，即提供 <code>Null</code> 对象所代表 <code>Robot</code> 的确切类型信息。这些信息是通过动态代理捕获的：</p><p>​ 无论何时，如果你需要一个空 <code>Robot</code> 对象，只需要调用 <code>newNullRobot()</code>，并传递需要代理的 <code>Robot</code> 的类型。这个代理满足了 <code>Robot</code> 和 <code>Null</code> 接口的需要，并提供了它所代理的类型的确切名字。</p><p>​ Mock 对象和桩</p><p>​ <strong>Mock 对象</strong>和 <strong>桩（Stub）</strong>在逻辑上都是 <code>Optional</code> 的变体。他们都是最终程序中所使用的“实际”对象的代理。不过，Mock 对象和桩都是假扮成那些可以传递实际信息的实际对象，而不是像 <code>Optional</code> 那样把包含潜在 <code>null</code> 值的对象隐藏</p><p>​ Mock 对象和桩之间的的差别在于程度不同。Mock 对象往往是轻量级的，且用于自测试。通常，为了处理各种不同的测试场景，我们会创建出很多 Mock 对象。而桩只是返回桩数据，它通常是重量级的，并且经常在多个测试中被复用。桩可以根据它们被调用的方式，通过配置进行修改。因此，桩是一种复杂对象，它可以做很多事情。至于 Mock 对象，如果你要做很多事，通常会创建大量又小又简单的 Mock 对象。</p><p>​ 接口和类型</p><p>​ <code>interface</code> 关键字的一个重要目标就是允许程序员隔离组件，进而<strong>降低耦合度</strong>。使用接口可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并不是对解耦的一种无懈可击的保障</p><p>​ 通过使用反射，仍然可以调用所有方法，甚至是 <code>private</code> 方法！如果知道方法名，你就可以在其 <code>Method</code> 对象上调用 <code>setAccessible(true)</code>，就像在 <code>callHiddenMethod()</code> 中看到的那样。</p><p>​ 任何方式都没法阻止反射调用那些非公共访问权限的方法。对于字段来说也是这样，即便是 <code>private</code> 字段：</p><p>​ 程序员往往对编程语言提供的访问控制过于自信，甚至认为 Java 在安全性上比其它提供了（明显）更宽松的访问控制的语言要优越。然而，正如你所看到的，事实并不是这样。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​ 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p><p>​ 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类</p><p>​ 泛型实现了<em>参数化类型</em>，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。</p><p>​ 与 C++ 的比较</p><p>​ Java 中的泛型需要与 C++ 进行对比</p><p>​ 只有知道了某个技术不能做什么，你才能更好地做到所能做的</p><p>​ 简单泛型</p><p>​ 一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足</p><p>​ 与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数</p><p>​ Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p><p>​ 一个元组类库</p><p>​ 有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象</p><p>​ 这个概念称为<em>元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象</em> 或 <em>信使</em> ）。</p><p>​ 一个堆栈类</p><p>​ 我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p><p>​ 内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数</p><p>​</p><p>​ RandomList</p><p>​ 作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型</p><p>​ 泛型接口</p><p>​ 泛型也可以应用于接口。例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象</p><p>​ 泛型方法</p><p>​ 到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系</p><p>​ 泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂</p><p>​ 要定义泛型方法，请将泛型参数列表放置在返回值之前</p><p>​ 变长参数和泛型方法</p><p>​ 泛型方法和变长参数列表可以很好地共存</p><p>​ 一个泛型的 Supplier</p><p>​ 这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法</p><p>​ 简化元组的使用</p><p>​ 使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库</p><p>​ 一个 Set 工具</p><p>​ 对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p><p>​ 构建复杂模型</p><p>​ 泛型的一个重要好处是能够简单安全地创建复杂模型</p><p>​ 泛型擦除</p><p>​ Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code></p><p>​ 理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一</p><p>​ 为了调用 <code>f()</code>，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p><p>​ 泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果某个类有一个返回 <strong>T</strong> 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型</p><p>​ 你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p><p>​ 迁移兼容性</p><p>​ 为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样</p><p>​ 擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</p><p>​ 擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。</p><p>​ 因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。</p><p>​ 擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p><p>​ 类库毫无争议是编程语言的一部分，对生产效率有着极大的影响</p><p>​</p><p>​ 擦除的问题</p><p>​ 因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p><p>​ 擦除和迁移兼容性意味着，使用泛型并不是强制的，</p><p>​ 边界处的动作</p><p>​ 因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物</p><p>​ 对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式</p><p>​ 即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保你放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</p><p>​ 泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型</p><p>​ 补偿擦除</p><p>​ 因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型</p><p>​ 有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它</p><p>​ 创建类型的实例</p><p>​ 试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）</p><p>​ 泛型数组</p><p>​ 正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong></p><p>​ 成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换</p><p>​ 由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 <strong>T</strong> 添加强制类型转换</p><p>​ 边界</p><p>​ <em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法</p><p>​ 通配符</p><p>​ 真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。</p><p>​ 但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p><p>​ 编译器有多聪明</p><p>​ 如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code></p><p>​ 逆变？</p><p>​ 还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管你不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 <strong>Collection</strong> 写入了</p><p>​ 无界通配符</p><p>​ 无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的</p><p>​ <strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List</strong> ”，而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 <strong>List</strong> ，只是我们不知道类型是什么。</p><p>​ 因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。</p><p>​ 捕获转换</p><p>​ 有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。</p><p>​ 捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 <strong>T</strong> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p><p>​ 问题</p><p>​ 任何基本类型都不能作为类型参数。</p><p>​ 解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么你将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样</p><p>​ 自动装箱机制解决了一些问题，但并没有解决所有问题。</p><p>​ 自动装箱不适用于数组，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组</p><p>​ 实现参数化接口</p><p>​ 个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口</p><p>​ 转型和警告</p><p>​ 使用带有泛型类型参数的转型或 <strong>instanceof</strong> 不会有任何效果</p><p>​ 通过泛型类来转型？</p><p>​ 重载</p><p>​ 当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名</p><p>​ 基类劫持接口</p><p>​ 一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p><p>​ 自限定的类型</p><p>​ 这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong></p><p>​ 古怪的循环泛型</p><p>​ 这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。 为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型</p><p>​ 注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p><p>​ 自限定 ？</p><p>​ 自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。 遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。 注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译</p><p>​ 因此很明显，自限定限制只能强制作用于继承关系</p><p>​ 参数协变 ？</p><p>​ 自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p><p>​ 自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样</p><p>​ <code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。 但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p><p>​ 动态类型安全</p><p>​ 因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</p><p>​ 泛型异常</p><p>​ 由于擦除的原因，<strong>catch</strong> 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 <strong>Throwable</strong>（这将进一步阻止你去定义不能捕获的泛型异常）。但是，类型参数可能会在一个方法的 <strong>throws</strong> 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码</p><p>​ 混型？</p><p>​ 术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。 混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题</p><p>​ C++ 中的混型？</p><p>​ 泛型类不能直接继承自一个泛型参数</p><p>​ 与接口混合？</p><p>​ 一种更常见的推荐解决方案是使用接口来产生混型效果</p><p>​ 使用装饰器模式？</p><p>​ 装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。</p><p>​ 也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p><p>​ 与动态代理混合</p><p>​ 可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。 由于动态代理的限制，每个被混入的类都必须是某个接口的实现</p><p>​ 因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。</p><p>​ 潜在类型机制</p><p>​ 在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p><p>​ 泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p><p>​ 潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方</p><p>​ 支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查</p><p>​ pyhton 中的潜在类型</p><p>​ <code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持 <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p><p>​ C++ 中的潜在类型</p><p>​ 在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。 C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</p><p>​ Go 中的潜在类型</p><p>​ <code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p><p>​ java中的直接潜在类型</p><p>​ 因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8 之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它</p><p>​ 对缺乏潜在类型机制的补偿</p><p>​ 尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p><p>​ 反射</p><p>​ 这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p><p>​ 将一个方法应用于序列</p><p>​ 反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？</p><p>​ Java8 中的辅助潜在类型</p><p>​ 尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p><p>​ 使用<strong>Suppliers</strong>类的通用方法</p><p>​ 通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p><p>​ 总结：类型转换真的如此之糟吗？</p><p>​ 使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等你在 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/12-Collections.md">集合</a> 和 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中</p><p>​ 但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当你从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的</p><p>​ 泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。</p><p>​ 正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​ 随着 Java Collection 和 Stream 类中高级功能的不断增加，日常编程中使用数组的需求也在变少，所以你暂且可以放心地略读甚至跳过这一章。但是，即使你自己避免使用数组，也总会有需要阅读别人数组代码的那一天。</p><p>​ 数组特性</p><p>​ 将数组和其他类型的集合区分开来的原因有三：效率，类型，保存基本数据类型的能力。在 Java 中，使用数组存储和随机访问对象引用序列是非常高效的。数组是简单的线性序列，这使得对元素的访问变得非常快。然而这种高速也是有代价的，代价就是数组对象的大小是固定的，且在该数组的生存期内不能更改。</p><p>​ 不管在编译时还是运行时，Java都会阻止你犯向对象发送不正确消息的错误。然而不管怎样，使用数组都不会有更大的风险。比较好的地方在于，如果编译器报错，最终的用户更容易理解抛出异常的含义。</p><p>​ 一个数组可以保存基本数据类型，而一个预泛型的集合不可以。然而对于泛型而言，集合可以指定和检查他们保存对象的类型，而通过 <strong>自动装箱</strong> (autoboxing)机制，集合表现地就像它们可以保存基本数据类型一样，因为这种转换是自动的。</p><p>​ 数组和 <strong>ArrayList</strong> 之间的相似是设计者有意为之，所以在概念上，两者很容易切换。但是就像你在<a href="https://github.com/LingCoder/OnJava8/tree/3c08903cf0e58229fe8ae1360869bc55d6dd7024/docs/book/book/12-Collections.md">集合</a>中看到的，集合的功能明显多于数组。随着 Java 自动装箱技术的出现，通过集合使用基本数据类型几乎和通过数组一样简单。数组唯一剩下的优势就是效率。然而，当你解决一个更加普遍的问题时，数组可能限制太多，这种情形下，您可以使用集合类。</p><p>​ 用于显示数组的实用程序</p><p>​ 一等对象</p><p>​ 不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 <strong>new</strong> 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 <strong>length</strong> 成员函数，它能告诉你数组对象中可以存储多少元素。<strong>[ ]</strong> 语法是你访问数组对象的唯一方式。</p><p>​ 返回数组</p><p>​ 假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。对 C++/C 这样的语言来说这是很困难的，因为你无法返回一个数组，只能是返回一个指向数组的指针。这会带来一些问题，因为对数组生存期的控制变得很混乱，这会导致内存泄露。</p><p>​ 多维数组</p><p>​ 非基元的对象数组也可以定义为不规则数组</p><p>​ 数组初始化时使用自动装箱技术</p><p>​ 泛型数组</p><p>​ 一般来说，数组和泛型并不能很好的结合。你不能实例化参数化类型的数组，类型擦除需要删除参数类型信息，而且数组必须知道它们所保存的确切类型，以强制保证类型安全。但是，可以参数化数组本身的类型。</p><p>​ 如果你知道你不会进行向上类型转换，你的需求相对简单，那么可以创建一个泛型数组，它将提供基本的编译时类型检查。然而，一个泛型 <strong>Collection</strong> 实际上是一个比泛型数组更好的选择。</p><p>​ 一般来说，您会发现泛型在类或方法的边界上是有效的。在内部，擦除常常会使泛型不可使用。</p><p>​ Arrays的fill方法</p><p>​</p><p>​ Arrays的setAll方法</p><p>​ 增量生成</p><p>​</p><p>​ 随机生成</p><p>​</p><p>​ 泛型和基本数组</p><p>​ 在本章的前面，我们被提醒，泛型不能和基元一起工作。在这种情况下，我们必须从基元数组转换为包装类型的数组，并且还必须从另一个方向转换。下面是一个转换器可以同时对所有类型的数据执行操作</p><p>​ 数组元素修改</p><p>​</p><p>​ 数组并行</p><p>​ 用简单的方法编写代码。不要开始处理并行性，除非它成为一个问题。您仍然会遇到并行性。在本章中，我们将介绍一些为并行执行而编写的Java库方法。因此，您必须对它有足够的了解，以便进行基本的讨论，并避免出现错误。</p><p>​ parallelSetAll()</p><p>​ 流式编程产生优雅的代码</p><p>​ Arrays工具类</p><p>​ 您已经看到了 <strong>java.util.Arrays</strong> 中的 <strong>fill()</strong> 和 <strong>setAll()/parallelSetAll()</strong> 。该类包含许多其他有用的 <strong>静态</strong> 程序方法，我们将对此进行研究</p><p>​ 数组拷贝</p><p>​ 与使用for循环手工执行复制相比，<strong>copyOf()</strong> 和 <strong>copyOfRange()</strong> 复制数组要快得多。这些方法被重载以处理所有类型</p><p>​ 数组比较</p><p>​ 数组相等的含义：数组必须有相同数量的元素，并且每个元素必须与另一个数组中的对应元素相等，对每个元素使用 <strong>equals()</strong>(对于原生类型，使用原生类型的包装类的 <strong>equals()</strong> 方法;例如，int的Integer.equals()。</p><p>​ 流和数组</p><p>​ <strong>stream()</strong> 方法很容易从某些类型的数组中生成元素流。</p><p>​ 通常，将数组转换为流来生成所需的结果要比直接操作数组容易得多。请注意，即使流已经“用完”(您不能重复使用它)，您仍然拥有该数组，因此您可以以其他方式使用它—-包括生成另一个流。</p><p>​ 数组排序</p><p>​ 编程设计的一个主要目标是“将易变的元素与稳定的元素分开”，在这里，保持不变的代码是一般的排序算法，但是变化的是对象的比较方式。因此，使用策略设计模式而不是将比较代码放入许多不同的排序源码中。使用策略模式时，变化的代码部分被封装在一个单独的类(策略对象)中。</p><p>​ Java有两种方式提供比较功能。第一种方法是通过实现 <strong>java.lang.Comparable</strong> 接口的原生方法。这是一个简单的接口，只含有一个方法 <strong>compareTo()</strong>。该方法接受另一个与参数类型相同的对象作为参数，如果当前对象小于参数，则产生一个负值;如果参数相等，则产生零值;如果当前对象大于参数，则产生一个正值。</p><p>​ Arrays.sort()的使用</p><p>​ Java标准库中使用的排序算法被设计为最适合您正在排序的类型—-原生类型的快速排序和对象的归并排序。</p><p>​ 并行排序</p><p>​ 如果排序性能是一个问题，那么可以使用 <strong>Java 8 parallelSort()</strong>，它为所有不可预见的情况(包括数组的排序区域或使用了比较器)提供了重载版本</p><p>​ binarySearch二分查找</p><p>​ 如果找到了搜索项，<strong>Arrays.binarySearch()</strong> 将生成一个大于或等于零的值。否则，它将产生一个负值，表示如果手动维护已排序的数组，则应该插入元素的位置。产生的值是 -(插入点) - 1 。插入点是大于键的第一个元素的索引，如果数组中的所有元素都小于指定的键，则是 <strong>a.size()</strong> 。</p><p>​ parallelPrefix并行前缀</p><p>​ 如前所述，使用流进行初始化非常优雅，但是对于大型数组，这种方法可能会耗尽堆空间。使用 <strong>setAll()</strong> 执行初始化更节省内存:</p><p>​ 因为正确使用 <strong>parallelPrefix()</strong> 可能相当复杂，所以通常应该只在存在内存或速度问题(或两者都有)时使用。否则，<strong>Stream.reduce()</strong> 应该是您的首选。</p><p>​ 在经历了这么多年的Java发展之后，我们可以很有趣地推测，如果重新开始，设计人员是否会将原生类型和低级数组放在该语言中(同样在JVM上运行的Scala语言不包括这些)。如果不考虑这些，就有可能开发出一种真正纯粹的面向对象语言(尽管有这样的说法，Java并不是一种纯粹的面向对象语言，这正是因为它的底层缺陷)。关于效率的最初争论总是令人信服的，但是随着时间的推移，我们已经看到了从这个想法向更高层次的组件(如集合)的演进。此外，如果集合可以像在某些语言中一样构建到核心语言中，那么编译器就有更好的机会进行优化。</p><p>​</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>​</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​ 类层次结构</p><p>​ 除了内存清理之外，所有的清理都不会自动发生</p><p>​</p><p>​</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="https://github.com/hyl2048" rel="external nofollow noreferrer">yulin</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://github.com/hyl2048/29494.html">https://github.com/hyl2048/29494.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="https://github.com/hyl2048" target="_blank">yulin</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><span class="chip bg-color">无标签</span></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><link rel="stylesheet" href="/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container" class="card-content"></div></div><script src="/libs/gitalk/gitalk.min.js"></script><script>let gitalk = new Gitalk({
        clientID: 'd55da70ade593eb887d8',
        clientSecret: 'e73646d4d0e5dc1c94985ad0a4a683c509c4b0b1',
        repo: 'hyl2048.github.io',
        owner: 'hyl2048',
        admin: "hyl2048",
        id: '2020-07-24T21-58-51',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');</script><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url("") 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"Q7ieo9PSWwtIK9dt4KyeSH0w-gzGzoHsz",appKey:"MEHtfyfhw8wH8P6tTgmu5Ag0",notify:!1,verify:!1,visitor:!0,avatar:"wavatar",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/41682.html"><div class="card-image"><img src="/medias/featureimages/17.jpg" class="responsive-img" alt="设计模式"> <span class="card-title">设计模式</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-07-25</span><span class="publish-author"><i class="fas fa-user fa-fw"></i> yulin</span></div></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/51507.html"><div class="card-image"><img src="/medias/featureimages/23.jpg" class="responsive-img" alt="算法与数据结构"> <span class="card-title">算法与数据结构</span></div></a><div class="card-content article-content"><div class="summary block-with-text">栈​ 问题类型： ​ 修改栈 ​ 递归与栈 ​ 树 ​ 利用栈实现队列 ​ 解法类型： ​</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-07-23</span><span class="publish-author"><i class="fas fa-user fa-fw"></i> yulin</span></div></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: huang<br />文章作者: yulin<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="/libs/codeBlock/codeBlockFuction.js"></script><script src="/libs/codeBlock/codeLang.js"></script><script src="/libs/codeBlock/codeCopy.js"></script><script src="/libs/codeBlock/codeShrink.js"></script><style>code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["(",")"]]}})</script><footer class="page-footer bg-color"><link rel="stylesheet" href="/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/libs/aplayer/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><div class="container row center-align"><div class="col s12 m8 l8 copy-right">&copy;huang. 版权所有 &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp; <span class="white-color">55.7k</span><br><span id="sitetime"></span><br><span id="busuanzi_container_site_pv" style="display:none"><i class="fa fa-heart-o"></i> 本站总访问量<span id="busuanzi_value_site_pv" class="white-color"></span></span> <span id="busuanzi_container_site_uv" style="display:none">人次,&nbsp;访客数<span id="busuanzi_value_site_uv" class="white-color"></span> 人.</span></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/hyl2048" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:qhuang724@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2745506937" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2745506937" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><script>$(document).ready(function(){var e=setInterval(function(){"none"!=document.getElementById("busuanzi_container_site_pv").style.display&&($("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html())+n),clearInterval(e));"none"!=$("#busuanzi_container_site_pv").css("display")&&($("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html())+t),clearInterval(e))},50),n=0,t=0})</script><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth()+1,n=o.getDate(),r=o.getHours(),l=o.getMinutes(),s=o.getSeconds(),M=Date.UTC(2020,3,28,0,0,0),g=Date.UTC(i,a,n,r,l,s)-M,m=Math.floor(g/31536e6),T=Math.floor(g/t-365*m),f=Math.floor((g-(365*m+T)*t)/e),h=Math.floor((g-(365*m+T)*t-f*e)/6e4),u=Math.floor((g-(365*m+T)*t-f*e-6e4*h)/1e3);document.getElementById("sitetime").innerHTML="本站已运行 "+m+" 年 "+T+" 天 "+f+" 小时 "+h+" 分钟 "+u+" 秒"}siteTime()</script><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script>$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script></body></html>