<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/41682.html"/>
      <url>/41682.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>On Java 8</title>
      <link href="/29494.html"/>
      <url>/29494.html</url>
      
        <content type="html"><![CDATA[<h2 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h2><p>​        把万物看作对象，对象之间在传递信息。</p><p>​        对象的创建，对象的存储（数量、类型），对象之间的关系处理（对象间传递信息），对象的销毁，异常处理</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>​        Java 为单继承语言，有别于多继承的C++</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>​        多样式与向上转型</p><p>​        多态和构造器</p><p>​        <strong>多态的好处</strong>在于解耦</p><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>​        组合和继承</p><p>​        构造器加载顺序（对比销毁顺序）</p><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>​        接口为抽象类</p><p>​        接口被用来建立类之间的协议</p><p>​        接口中的守卫方法或虚拟扩展方法（default）</p><p>​        类可以实现多个接口，但是抽象类只能继承单一抽象类</p><p>​        面向接口编程，将接口与实现解耦可以应用于多种不同的实现</p><p>​        选择问题：</p><p>​                尽可能地抽象，更倾向使用接口而非抽象类</p><p>​        接口和策略模式</p><p>​        接口和工厂模式</p><p>​        优先使用类而不是接口，若有必要使用接口，再对代码重构也不迟。如果只是单纯为了设计接口而设计接口，只会徒增复杂性。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>​        内部自动类拥有对外部类所有成员的访问权，外部类与内部类产生的引用</p><p>​        匿名内部类，与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备，而如果是实现接口，也只能实现一个接口。</p><p>​        嵌套类</p><p>​        <strong>内部类有效地实现了多重继承</strong>，每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实习，对于内部类都没有影响</p><p>​        内部类的其他特性：</p><p>​                内部类可以有多个实例</p><p>​                再单个外部类中，可以让多个内部类以不同的方        式实现</p><p>​                创建内部类对象的时刻并不依赖于外部类对象的        创建</p><p>​                内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体    </p><p>​        内部类提供的闭包功能，相比指针更灵活更安全</p><p>​        回调的价值在于它的灵活性-可以再运行时动态地决定需要调用什么方法</p><p>​        在控制框架使用内部类的价值</p><p>​        局部内部类和匿名内部类</p><p>设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>​        <strong>持有对象</strong>的思想</p><p>​        泛型与类型安全的集合</p><p>​        散列码和hashCode()</p><p>​        List可以在创建后添加或删除元素，并自行调整大小</p><p>​        collection</p><p>​        迭代器，能够将遍历序列的操作与该序列的底层结构分离</p><p>​        for-in 和迭代器</p><p>​        集合和迭代器</p><p>​        <img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Ccollection.png" alt="collection"></p><p>​                                                                </p><p>​                上图中用粗黑的框包裹的类为常用的类</p><p><img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Ccollection1.png" alt="collection1"></p><p><img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Cmap.png" alt="map"></p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>​            lambda表达式</p><p>​            方法引用</p><p>​            函数式接口：</p><p>​                    在使用函数式接口时，名称无关紧要，只要参数类型和返回类型相同</p><p>​            高阶函数</p><p>​            闭包，利用闭包可以轻松生成函数。支持闭包也叫变量捕获。只要有内部类就会有闭包</p><p>​                    等同final效果</p><p>​            函数组合，多个还能输组合成新函数    </p><p>​            柯里化和部分求值</p><p>​                        柯里化，将一个多参数函数转换为一系列单参数函数</p><p>​            纯函数式编程，Scala，Clojure</p><h2 id="流式编程"><a href="#流式编程" class="headerlink" title="流式编程"></a>流式编程</h2><p>​            集合优化了对象的存储，而流和对象有关。流是一系列与特定存储机制无关的元素。利用流，可以不迭代集合中的元素，就可以提取和操作数据。<strong>流的好处是，它使得程序更加短小和容易理解</strong>。</p><p>​            Lambda表达式和方法引用结合流式编程会更加简便、简洁。</p><p>​            流式编程是一种声明式编程，声明要做什么，而非怎么做的编程风格。</p><p>​            流式编程采用内部迭代。</p><p>​            流是懒加载的。</p><p>​            流操作，创建流，修该流元素，消费流元素</p><p>​            创建流：</p><p>​                    stream.of(); stream(); 集合通过stream()方法来产生一个流。</p><p>​            中级流操作</p><p>​            optional类</p><p>​            终端操作</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>​            异常处理程序，不仅能节省代码，而且把“描述在正常执行剁成中做什么事”和“出了问题怎么办”的代码相分离。异常机制使代码的阅读、编写和调试工作更加井井有条。</p><p>​            基本异常</p><p>​            异常捕获</p><p>​            自定义异常</p><p>​            异常声明</p><p>​                    重新抛出异常</p><p>​                    异常链</p><p>​            Java标准异常</p><p>​            finally 用于把除内存之外的资源恢复到他们初始状态时。如果把finally子句和带标签的break及continue配合使用，在Java里就没必要使用goto语句了</p><p>​            异常丢失</p><p>​            异常限制</p><p>​            构造器和异常处理</p><p>​            Try-With-Resources和构造器异常处理</p><p>​            异常匹配</p><p>​            异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。异常处理的一个中哟啊目标就是把错误处理的代码同错误发生的地点相分离。</p><p>​            <strong>吞了异常</strong></p><p>​            被检查的异常与并发症</p><p>​                    所有模型都是错误的，但有些是            能用的。</p><p>​            反射和泛型就是用来补偿静态类型检查所带来的过多限制。</p><p>​            好的程序设计语言能帮助程序员写出好程序，但无论哪种语言都避免不了程序员用它写出坏程序。</p><p>​            把被检查的异常转换为不检查的异常</p><p>​                    异常链</p><p>​                    用RuntimeException来包装，被检查的异常</p><p>​            异常指南</p><p>​                    1.尽可能使用 try-with-resource。</p><p>​                    2.在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）</p><p>​                    3.解决问题并且重新调用产生异常的方法。</p><p>​                    4.进行少许修补，然后绕过异常发生的地方继续执行。</p><p>​                    5.用别的数据进行计算，以代替方法预计会返回的值。</p><p>​                    6.把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</p><p>​                    7.把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</p><p>​                    8.终止程序。</p><p>​                    9.进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。）</p><p>​                    10.让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）</p><p>​            报告功能是异常的精髓所在</p><h2 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h2><p>让代码健壮的方法    </p><p>​        测试</p><p>​                单元测试</p><p>​        前置条件（契约式设计DBC）</p><p>​                断言</p><p>​                Java断言语法</p><p>​                Guava断言</p><p>​                检查指令</p><p>​        测试驱动开发（TDD）</p><p>​        日志</p><p>​        调试</p><p>​                JDB、图形化调试器</p><p>​        基准测试</p><p>​        剖析和优化</p><p>​                剖析和优化</p><p>​                优化准则</p><p>​                        避免为了性能牺牲代码的可读性。</p><p>​                        不要独立地看待性能。衡量与带来的收益相                比所需投入的工作量。</p><p>​                        程序的大小很重要。性能优化通常只对运行                了长时间的大型项目有价值。性能通常不是小项                目的关注点。</p><p>​                        运行起来程序比一心钻研它的性能具有更高                的优先级。一旦你已经有了可工作的程序，如有                必要的话，你可以使用剖析器提高它的效率。只                有当性能是关键因素时，才需要在设计/开发阶段                考虑性能。</p><p>​                        不要猜测瓶颈发生在哪。运行剖析器，让剖                析器告诉你。</p><p>​                        无论何时有可能的话，显式地设置实例为                 null 表明你不再用它。这对垃圾收集器来说是个                有用的暗示。</p><p>​                        <strong>static final</strong> 修饰的变量会被 JVM 优化从而                提高程序的运行速度。因而程序中的常量应该声                明 <strong>static final</strong>。</p><p>​        风格检测</p><p>​        静态错误分析</p><p>​        代码重审</p><p>​        结对编程</p><p>​        重构：</p><p>​                重构基石：</p><p>​                        测试</p><p>​                        自动构建</p><p>​                        版本控制</p><p>​        持续集成</p><p>​                持续集成服务器</p><p>​                持续集成需要分布式版本管理，自动构建和自动        测测试系统作为基础</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>​        流与文件结合使得文件操作编程变得更加优雅</p><p>​        文件和目录路径</p><p>​                选取部分路径片段</p><p>​                路径分析</p><p>​                        FIile工具类</p><p>​        文件系统</p><p>​        路径监听</p><p>​                文件删除和线程</p><p>​        文件查找</p><p>​        文件读写</p><p>​        </p><p>​        java.nio.file        </p><p>​        java.nio.file.Files</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>​        字符串的不可变</p><p>​                参数是为该方法提供信息的，而不是想让该方法        改变自己的</p><p>​        +的重载与StringBuilder</p><p>​                不可变性与效率，string与stringbuilder类</p><p>​                在有循环且有性能问题时，使用stringbuilder类</p><p>​                stringbuffer与stringbuilder，stringbuffer是线        程安全的，因此开销会大一些。</p><p>​        意外递归</p><p>​                打印对象内存地址，使用super.tostring()，而不        去使用this, 使用this会发生自动类型转换、递归调用</p><p>​        字符串操作</p><p>​                当需要改变字符串的内容时，<code>String</code> 类的方法        都会返回一个新的 <code>String</code> 对象。同时，如果内容不        改变，<code>String</code> 方法只是返回原始对象的一个引用而        已。这可以节约存储空间以及避免额外的开销</p><p>​                在 Java 中，字符串操作还主要集中于<code>String</code>、        <code>StringBuffer</code> 和 <code>StringTokenizer</code> 类</p><p>​        格式化输出</p><p>​                printf()</p><p>​                System.out.format()</p><p>​                Formatter类，</p><p>​                        在 Java 中，所有的格式化功能都是由                <code>java.util.Formatter</code> 类处理的。</p><p>​        格式化修饰符</p><p>​                <code>Formatter</code> 转换</p><p>​                        还有许多不常用的类型转换与格式修饰符选                项，你可以在 JDK 文档中的 <code>Formatter</code> 类部分                找到它们。</p><p>​                String.format()</p><p>​                        在 <code>String.format()</code> 内部，它也是创建了                一个 <code>Formatter</code> 对象，然后将你传入的参数转                给 <code>Formatter</code>。不过，与其自己做这些事情，不                如使用便捷的 <code>String.format()</code> 方法，何况这                样的代码更清晰易读。</p><p>​        一个十六进制转储（dump）工具</p><p>​                为了打开及读入二进制文件，我们用到了另一个        工具 <code>Files.readAllBytes()</code>，这已经在 <a href="">Files章节</a>         介绍过了。这里的 <code>readAllBytes()</code> 方法将整个文件        以 <code>byte</code> 数组的形式返回</p><p>​        正则表达式</p><p>​                处理string的匹配、选择、编辑以及验证</p><p>​                <code>String.split()</code> 还有一个重载的版本，它允许        你限制字符串分割的次数</p><p>​        创建正则表达式</p><p>​                正则表达式的完整构造子列表，请参考JDK文档         <code>java.util.regex</code> 包中的 <code>Pattern</code>类</p><p>​                当你学会了使用字符类（character classes）之        后，正则表达式的威力才能真正显现出来</p><p>​        量词</p><p>​                量词描述了一个模式捕获输入文本的方式</p><p>​        CharSequence</p><p>​                接口 <code>CharSequence</code> 从 <code>CharBuffer</code>、                <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 类中抽象        出了字符序列的一般化定义</p><p>​        Pattern<code>和</code>Matcher</p><p>​                java.util.regext.Matcher</p><p>​        <code>find()</code></p><p>​                <code>Matcher.find()</code> 方法可用来在 <code>CharSequence</code>         中查找多个匹配</p><p>​        start()<code>和</code>end()</p><p>​        <code>Pattern</code> 标记</p><p>​        split()</p><p>​        替换操作</p><p>​        reset()</p><p>​        正则表达式与 Java I/O</p><p>​        扫描输入</p><p>​                <code>Scanner</code> 分隔符</p><p>​        StringTokenizer类</p><p>​                在 Java 引入正则表达式（J2SE1.4）和         <code>Scanner</code> 类（Java SE5）之前，分割字符        串的唯一方法是使用 <code>StringTokenizer</code> 来        分词。不过，现在有了正则表达式和             <code>Scanner</code>，我们可以使用更加简单、更加简洁        的方式来完成同样的工作了</p><p>​                基本上，我们可以放心地说，                <code>StringTokenizer</code> 已经可以废弃不用了。</p><h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p>​        java如何在运行时识别对象和类信息：</p><p>​                “传统的”RTTI（运行时类型信息）</p><p>​                            使用 RTTI，我们可以查询某个                 <code>Shape</code> 引用所指向对象的确切类型，                然后择或者剔除特例。</p><p>​                “反射”机制：允许我们在运行时发现和        使用类信息。</p><p>​        <code>Class</code> 对象</p><p>​                类加载器</p><p>​                原生类加载器与额外的类加载器</p><p>​                        <code>Class</code> 对象仅在需要的时候才会被                加载，<code>static</code> 初始化是在类加载时进                行的</p><p>​                        无论何时，只要你想在运行时使用                类型信息，就必须先得到那个 <code>Class</code> 对                象的引    用。<code>Class.forName()</code> 就是                实现这个功能的一个便捷途径，因为使                用该方法你不需要先持有这个类型 的对                象。但是，如果你已经拥有了目标类的                对象，那就可以通过调用 <code>getClass()</code>                 方法来获取 <code>Class</code> 引用了，这个方法来                自根类 <code>Object</code>，它将返回表示该对象                实际类型的 <code>Class</code> 对象的引用</p><p>​                        <code>Class</code> 对象的 <code>newInstance()</code> 方                法是实现“虚拟构造器”的一种途径，虚                拟构造器可以让你在不知道一个类的确                切类型的时候，创建这个类的对象</p><p>​        类字面常量</p><p>​                类字面常量用于生成类对象的引用</p><p>​                为了使用类而做的准备工作实际包含三        个步骤</p><p>​                加载：这是由类加载器执行的。该步骤        将查找字节码（通常在 classpath 所指定的        路径中查找，但这并非是必须的），并从这        些字节码中创建一个 <code>Class</code> 对象</p><p>​                链接：在链接阶段将验证类中的字节        码，为 <code>static</code> 字段分配存储空间，并且如        果需要的话，将解析这个类创建的对其他类        的所有引用。</p><p>​                初始化：如果该类具有超类，则先初始        化超类，执行 <code>static</code> 初始化器和 <code>static</code>         初始化块。</p><p>​                仅使用 <code>.class</code> 语法来获得对类对象的        引用不会引发初始化。但与此相反，使用         <code>Class.forName()</code> 来产生 <code>Class</code> 引用会        立即就进行初始化</p><p>​        泛化的 <code>Class</code> 引用</p><p>​                向 <code>Class</code> 引用添加泛型语法的原因只是        为了提供编译期类型检查</p><p>​        <code>cast()</code> 方法</p><p>​                 Java 中用于 <code>Class</code> 引用的转型语                     法</p><p>​        类型转换检测    </p><p>​                已知的 RTTI 类型</p><p>​                        传统的类型转换，如 “<code>(Shape)</code>”，                由 RTTI 确保转换的正确性，如果执行了                一个        错误的类型转换，就会抛出一                个 <code>ClassCastException</code> 异常。</p><p>​                        代表对象类型的 <code>Class</code> 对象. 通过                查询 <code>Class</code> 对象可以获取运行时所需的                信息.</p><p>​                RTTI 在 Java 中还有第三种形式，那就        是关键字 <code>instanceof</code></p><p>​                 使用类字面量</p><p>​                        使用类字面量重新实现                     <code>PetCreator</code> 类的话，其结果在                很多方面都会更清晰。</p><p>​                一个动态 <code>instanceof</code> 函数</p><p>​                        <code>Class.isInstance()</code> 方法提供                了一种动态测试对象类型的方法。</p><p>​                        <code>isInstance()</code> 方法消除了对                 <code>instanceof</code> 表达式的需要</p><p>​                递归计数</p><p>​                        可以使用                                         <code>Class.isAssignableFrom()</code> 而不是预加载 <code>Map</code> ，并创建一个不限于计数 <code>Pet</code> 的通用工具</p><p>​                注册工厂</p><p>​                        </p><p>​        类的等价比较</p><p>​                查询类型信息时，需要注意：            instanceof 的形式(即 <code>instanceof</code> 或     <code>isInstance()</code> ，这两者产生的结果相同) 和与 Class 对象直接比较这两者间存在重要区别</p><p>​                <code>instanceof</code> 说的是“你是这个类，还是从这个类派生的类？”。而如果使用 <code>==</code> 比较实际的<code>Class</code> 对象，则与继承无关 —— 它要么是确切的类型，要么不是。</p><p>​        反射：运行时类信息</p><p>​                如果你不知道对象的确切类型，RTTI 会告        诉你。但是，有一个限制：必须在编        译时        知道类型，才能使用 RTTI 检测它，并对信息做        一些有用的事情。换句话说，编译器必须知道你        使用的所有类</p><p>​                反射提供了检测可用方法并生成方法名称        的机制</p><p>​                在运行时发现类信息的另一个令人信服的        动机是提供跨网络在远程平台上创建和执行对象        的能力。这称为<em>远程方法调用</em>（RMI），它使         Java 程序的对象分布在许多机器上</p><p>​                重要的是要意识到反射没有什么魔力。当        你使用反射与未知类型的对象交互时，JVM 将查        看该对象，并看到它属于特定的类（就像普通的         RTTI）。在对其执行任何操作之前，必须加载         <code>Class</code> 对象。因此，该特定类型的 <code>.class</code>         文件必须在本地计算机上或通过网络对 JVM 仍        然可用。因此，RTTI 和反射的真正区别在于，        使用 RTTI 时，编译器在编译时会打开并检查         .class文件。换句话说，你可以用“正常”的方式        调用一个对象的所有方法。通过反射，.class文        件在编译时不可用；它由运行时环境        打开        并检查。</p><p>​        类方法提取器</p><p>​                反射是用来支持其他java特性的，如对象序        列化、动态提取有关类的信息</p><p>​                编程时，当你不记得某个类是否有特定的        方法，并且不想在 JDK 文档中搜索索引或类层        次结构时，或者如果你不知道该类是否可以对         <code>Color</code> 对象执行任何操作时，该工具能节省不        少时间</p><p>​        动态代理</p><p>​                当你希望将额外的操作与“真实对象”做分离        时，代理可能会有所帮助，尤        其是当你想要轻松        地启用额外的操作时，反之亦然（设计模式就是        封装        变更—所以你必须改变一些东西以证明模        式的合理性）。例如，如果你想跟踪        RealObject中方法的调用，或衡量此类调用的开销，该怎么        办？你不想这部分    代码耦合到你的程序中，而代理能使你可以很轻松地添加或删除它</p><p>​                Java 的<em>动态代理</em>更进一步，不仅动态创建代理对        象而且动态处理对代理方法的调用。在动态代理上进行        的所有调用都被重定向到单个<em>调用处理程序</em>，该处理程        序负责发现调用的内容并决定如何处理</p><p>​                可以通过调用静态方法Proxy.newProxyInstance()来创建动态代理，该方法需要一个类加载器（通常可以从已加载的对象中获取）</p><p>​                通常执行代理操作，然后使用 <code>Method.invoke()</code> 将请求转发给被代理对象，并携带必要的参数。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是，可以过滤某些方法调用，同时传递其他方法调用：</p><p>​        Optional类</p><p>​                如果你使用内置的 <code>null</code> 来表示没有对象，每次        使用引用的时候就必须测试一下引用是否为 <code>null</code>，这        显得有点枯燥，而且势必会产生相当乏味的代码。问题        在于 <code>null</code> 没什么自己的行为，只会在你想用它执行        任何操作的时候产生 <code>NullPointException</code>。        <code>java.util.Optional</code>（首次出现是在<a href="https://github.com/LingCoder/OnJava8/tree/5d7462a629a410cb29f98938387daa0d846d8e4b/docs/book/docs/book/13-Functional-Programming.md">函数式编程</a>这            章）为 <code>null</code> 值提供了一个轻量级代理，<code>Optional</code>         对象可以防止你的代码直接抛出NullPointException。</p><p>​        标记接口</p><p>​                有时候使用一个<strong>标记接口</strong>来表示空值会更方便。标记接口里边什么都没有，你只要把它的名字当做标签来用就可以。</p><p>​                假设存在许多不同类型的 <code>Robot</code>，我们想让每种 <code>Robot</code> 都创建一个 <code>Null</code> 对象来执行一些特殊的操作——在本例中，即提供 <code>Null</code> 对象所代表 <code>Robot</code> 的确切类型信息。这些信息是通过动态代理捕获的：</p><p>​                无论何时，如果你需要一个空 <code>Robot</code> 对象，只需要调用 <code>newNullRobot()</code>，并传递需要代理的 <code>Robot</code> 的类型。这个代理满足了 <code>Robot</code> 和 <code>Null</code> 接口的需要，并提供了它所代理的类型的确切名字。</p><p>​        Mock 对象和桩</p><p>​                <strong>Mock 对象</strong>和 <strong>桩（Stub）</strong>在逻辑上都是 <code>Optional</code> 的变体。他们都是最终程序中所使用的“实际”对象的代理。不过，Mock 对象和桩都是假扮成那些可以传递实际信息的实际对象，而不是像 <code>Optional</code> 那样把包含潜在 <code>null</code> 值的对象隐藏</p><p>​                Mock 对象和桩之间的的差别在于程度不同。Mock 对象往往是轻量级的，且用于自测试。通常，为了处理各种不同的测试场景，我们会创建出很多 Mock 对象。而桩只是返回桩数据，它通常是重量级的，并且经常在多个测试中被复用。桩可以根据它们被调用的方式，通过配置进行修改。因此，桩是一种复杂对象，它可以做很多事情。至于 Mock 对象，如果你要做很多事，通常会创建大量又小又简单的 Mock 对象。</p><p>​            接口和类型</p><p>​                    <code>interface</code> 关键字的一个重要目标就是允许程序员隔离组件，进而<strong>降低耦合度</strong>。使用接口可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并不是对解耦的一种无懈可击的保障</p><p>​                    通过使用反射，仍然可以调用所有方法，甚至是 <code>private</code> 方法！如果知道方法名，你就可以在其 <code>Method</code> 对象上调用 <code>setAccessible(true)</code>，就像在 <code>callHiddenMethod()</code> 中看到的那样。</p><p>​                    任何方式都没法阻止反射调用那些非公共访问权限的方法。对于字段来说也是这样，即便是 <code>private</code> 字段：</p><p>​                    程序员往往对编程语言提供的访问控制过于自信，甚至认为 Java 在安全性上比其它提供了（明显）更宽松的访问控制的语言要优越。然而，正如你所看到的，事实并不是这样。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​            普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p><p>​            多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类</p><p>​            泛型实现了<em>参数化类型</em>，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。</p><p>​            与 C++ 的比较</p><p>​                    Java 中的泛型需要与 C++ 进行对比</p><p>​                    只有知道了某个技术不能做什么，你才能更好地做到所能做的</p><p>​            简单泛型</p><p>​                    一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足</p><p>​                    与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数</p><p>​                     Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p><p>​            一个元组类库</p><p>​                    有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象</p><p>​                    这个概念称为<em>元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象</em> 或 <em>信使</em> ）。</p><p>​            一个堆栈类</p><p>​                    我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p><p>​                    内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数</p><p>​            </p><p>​            RandomList</p><p>​                    作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型</p><p>​            泛型接口</p><p>​                    泛型也可以应用于接口。例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象</p><p>​            泛型方法</p><p>​                    到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系</p><p>​                    泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂</p><p>​                    要定义泛型方法，请将泛型参数列表放置在返回值之前</p><p>​            变长参数和泛型方法</p><p>​                    泛型方法和变长参数列表可以很好地共存</p><p>​            一个泛型的 Supplier</p><p>​                    这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法</p><p>​            简化元组的使用</p><p>​                    使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库</p><p>​            一个 Set 工具</p><p>​                    对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p><p>​            构建复杂模型</p><p>​                    泛型的一个重要好处是能够简单安全地创建复杂模型</p><p>​            泛型擦除</p><p>​                    Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code></p><p>​                    理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一</p><p>​                    为了调用 <code>f()</code>，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p><p>​                    泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果某个类有一个返回 <strong>T</strong> 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型</p><p>​                    你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p><p>​            迁移兼容性</p><p>​                    为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样</p><p>​                    擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</p><p>​                    擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。</p><p>​                    因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。    </p><p>​                    擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p><p>​                    类库毫无争议是编程语言的一部分，对生产效率有着极大的影响</p><p>​            </p><p>​            擦除的问题</p><p>​                    因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p><p>​                    擦除和迁移兼容性意味着，使用泛型并不是强制的，</p><p>​            边界处的动作</p><p>​                    因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物</p><p>​                    对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式</p><p>​                    即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保你放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</p><p>​                    泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型</p><p>​            补偿擦除</p><p>​                    因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型</p><p>​                    有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它</p><p>​            创建类型的实例</p><p>​                    试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）</p><p>​            泛型数组</p><p>​                    正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong></p><p>​                    成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换</p><p>​                    由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 <strong>T</strong> 添加强制类型转换</p><p>​            边界</p><p>​                    <em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法</p><p>​            通配符</p><p>​                    真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。</p><p>​                    但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p><p>​            编译器有多聪明</p><p>​                    如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code></p><p>​            逆变？</p><p>​                    还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管你不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 <strong>Collection</strong> 写入了</p><p>​            无界通配符</p><p>​                    无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的</p><p>​                    <strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List</strong> ”，而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 <strong>List</strong> ，只是我们不知道类型是什么。</p><p>​                    因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。</p><p>​            捕获转换</p><p>​                    有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。</p><p>​                    捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 <strong>T</strong> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p><p>​            问题</p><p>​                    任何基本类型都不能作为类型参数。</p><p>​                            解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么你将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样</p><p>​                            自动装箱机制解决了一些问题，但并没有解决所有问题。</p><p>​                            自动装箱不适用于数组，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组</p><p>​                    实现参数化接口</p><p>​                            个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口</p><p>​                    转型和警告</p><p>​                            使用带有泛型类型参数的转型或 <strong>instanceof</strong> 不会有任何效果</p><p>​                            通过泛型类来转型？</p><p>​                    重载</p><p>​                            当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名</p><p>​                    基类劫持接口</p><p>​                            一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p><p>​                    自限定的类型</p><p>​                            这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong></p><p>​                    古怪的循环泛型</p><p>​                            这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。 为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型</p><p>​                            注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p><p>​                    自限定    ？</p><p>​                            自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。 遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。 注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译</p><p>​                            因此很明显，自限定限制只能强制作用于继承关系</p><p>​                    参数协变 ？</p><p>​                            自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p><p>​                            自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样</p><p>​                            <code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。 但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p><p>​                    动态类型安全</p><p>​                            因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</p><p>​                    泛型异常</p><p>​                            由于擦除的原因，<strong>catch</strong> 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 <strong>Throwable</strong>（这将进一步阻止你去定义不能捕获的泛型异常）。但是，类型参数可能会在一个方法的 <strong>throws</strong> 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码</p><p>​                    混型？</p><p>​                            术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。 混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题</p><p>​                    C++ 中的混型？</p><p>​                            泛型类不能直接继承自一个泛型参数</p><p>​                    与接口混合？</p><p>​                            一种更常见的推荐解决方案是使用接口来产生混型效果</p><p>​                    使用装饰器模式？</p><p>​                             装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。</p><p>​                            也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p><p>​                    与动态代理混合</p><p>​                            可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。 由于动态代理的限制，每个被混入的类都必须是某个接口的实现</p><p>​                            因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。</p><p>​                    潜在类型机制</p><p>​                            在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p><p>​                            泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p><p>​                            潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方</p><p>​                            支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查</p><p>​                    pyhton 中的潜在类型</p><p>​                            <code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持 <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p><p>​                    C++ 中的潜在类型</p><p>​                            在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。 C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</p><p>​                    Go 中的潜在类型</p><p>​                            <code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p><p>​                    java中的直接潜在类型</p><p>​                            因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8 之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它</p><p>​                    对缺乏潜在类型机制的补偿</p><p>​                            尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p><p>​                            反射    </p><p>​                                    这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p><p>​                            将一个方法应用于序列    </p><p>​                                    反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？    </p><p>​                    Java8 中的辅助潜在类型</p><p>​                            尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p><p>​                    使用<strong>Suppliers</strong>类的通用方法</p><p>​                            通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p><p>​                    总结：类型转换真的如此之糟吗？</p><p>​                            使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等你在 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/12-Collections.md">集合</a> 和 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中</p><p>​                            但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当你从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的</p><p>​                            泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。</p><p>​                            正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​            随着 Java Collection 和 Stream 类中高级功能的不断增加，日常编程中使用数组的需求也在变少，所以你暂且可以放心地略读甚至跳过这一章。但是，即使你自己避免使用数组，也总会有需要阅读别人数组代码的那一天。</p><p>​            数组特性</p><p>​                    将数组和其他类型的集合区分开来的原因有三：效率，类型，保存基本数据类型的能力。在 Java 中，使用数组存储和随机访问对象引用序列是非常高效的。数组是简单的线性序列，这使得对元素的访问变得非常快。然而这种高速也是有代价的，代价就是数组对象的大小是固定的，且在该数组的生存期内不能更改。</p><p>​                    不管在编译时还是运行时，Java都会阻止你犯向对象发送不正确消息的错误。然而不管怎样，使用数组都不会有更大的风险。比较好的地方在于，如果编译器报错，最终的用户更容易理解抛出异常的含义。</p><p>​                    一个数组可以保存基本数据类型，而一个预泛型的集合不可以。然而对于泛型而言，集合可以指定和检查他们保存对象的类型，而通过 <strong>自动装箱</strong> (autoboxing)机制，集合表现地就像它们可以保存基本数据类型一样，因为这种转换是自动的。</p><p>​                    数组和 <strong>ArrayList</strong> 之间的相似是设计者有意为之，所以在概念上，两者很容易切换。但是就像你在<a href="https://github.com/LingCoder/OnJava8/tree/3c08903cf0e58229fe8ae1360869bc55d6dd7024/docs/book/book/12-Collections.md">集合</a>中看到的，集合的功能明显多于数组。随着 Java 自动装箱技术的出现，通过集合使用基本数据类型几乎和通过数组一样简单。数组唯一剩下的优势就是效率。然而，当你解决一个更加普遍的问题时，数组可能限制太多，这种情形下，您可以使用集合类。</p><p>​            用于显示数组的实用程序</p><p>​            一等对象</p><p>​                    不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 <strong>new</strong> 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 <strong>length</strong> 成员函数，它能告诉你数组对象中可以存储多少元素。<strong>[ ]</strong> 语法是你访问数组对象的唯一方式。</p><p>​            返回数组</p><p>​                    假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。对 C++/C 这样的语言来说这是很困难的，因为你无法返回一个数组，只能是返回一个指向数组的指针。这会带来一些问题，因为对数组生存期的控制变得很混乱，这会导致内存泄露。</p><p>​            多维数组</p><p>​                    非基元的对象数组也可以定义为不规则数组</p><p>​                    数组初始化时使用自动装箱技术</p><p>​            泛型数组</p><p>​                    一般来说，数组和泛型并不能很好的结合。你不能实例化参数化类型的数组，类型擦除需要删除参数类型信息，而且数组必须知道它们所保存的确切类型，以强制保证类型安全。但是，可以参数化数组本身的类型。</p><p>​                    如果你知道你不会进行向上类型转换，你的需求相对简单，那么可以创建一个泛型数组，它将提供基本的编译时类型检查。然而，一个泛型 <strong>Collection</strong> 实际上是一个比泛型数组更好的选择。</p><p>​                    一般来说，您会发现泛型在类或方法的边界上是有效的。在内部，擦除常常会使泛型不可使用。</p><p>​            Arrays的fill方法</p><p>​                    </p><p>​            Arrays的setAll方法</p><p>​            增量生成</p><p>​                    </p><p>​            随机生成</p><p>​                    </p><p>​            泛型和基本数组</p><p>​                    在本章的前面，我们被提醒，泛型不能和基元一起工作。在这种情况下，我们必须从基元数组转换为包装类型的数组，并且还必须从另一个方向转换。下面是一个转换器可以同时对所有类型的数据执行操作</p><p>​            数组元素修改</p><p>​                    </p><p>​            数组并行</p><p>​                    用简单的方法编写代码。不要开始处理并行性，除非它成为一个问题。您仍然会遇到并行性。在本章中，我们将介绍一些为并行执行而编写的Java库方法。因此，您必须对它有足够的了解，以便进行基本的讨论，并避免出现错误。</p><p>​            parallelSetAll()</p><p>​                    流式编程产生优雅的代码</p><p>​            Arrays工具类</p><p>​                    您已经看到了 <strong>java.util.Arrays</strong> 中的 <strong>fill()</strong> 和 <strong>setAll()/parallelSetAll()</strong> 。该类包含许多其他有用的 <strong>静态</strong> 程序方法，我们将对此进行研究</p><p>​            数组拷贝</p><p>​                    与使用for循环手工执行复制相比，<strong>copyOf()</strong> 和 <strong>copyOfRange()</strong> 复制数组要快得多。这些方法被重载以处理所有类型</p><p>​            数组比较</p><p>​                    数组相等的含义：数组必须有相同数量的元素，并且每个元素必须与另一个数组中的对应元素相等，对每个元素使用 <strong>equals()</strong>(对于原生类型，使用原生类型的包装类的 <strong>equals()</strong> 方法;例如，int的Integer.equals()。</p><p>​            流和数组</p><p>​                    <strong>stream()</strong> 方法很容易从某些类型的数组中生成元素流。</p><p>​                    通常，将数组转换为流来生成所需的结果要比直接操作数组容易得多。请注意，即使流已经“用完”(您不能重复使用它)，您仍然拥有该数组，因此您可以以其他方式使用它—-包括生成另一个流。</p><p>​            数组排序</p><p>​                    编程设计的一个主要目标是“将易变的元素与稳定的元素分开”，在这里，保持不变的代码是一般的排序算法，但是变化的是对象的比较方式。因此，使用策略设计模式而不是将比较代码放入许多不同的排序源码中。使用策略模式时，变化的代码部分被封装在一个单独的类(策略对象)中。</p><p>​                    Java有两种方式提供比较功能。第一种方法是通过实现 <strong>java.lang.Comparable</strong> 接口的原生方法。这是一个简单的接口，只含有一个方法 <strong>compareTo()</strong>。该方法接受另一个与参数类型相同的对象作为参数，如果当前对象小于参数，则产生一个负值;如果参数相等，则产生零值;如果当前对象大于参数，则产生一个正值。</p><p>​            Arrays.sort()的使用</p><p>​                    </p><p>​            并行排序</p><p>​            binarySearch二分查找</p><p>​            parallelPrefix并行前缀</p><p>​                    </p><p>​            </p><p>​                    </p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​            </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​            类层次结构</p><p>​            除了内存清理之外，所有的清理都不会自动发生</p><p>​        </p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构</title>
      <link href="/51507.html"/>
      <url>/51507.html</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>​        问题类型：</p><p>​                修改栈</p><p>​                递归与栈</p><p>​                树</p><p>​                利用栈实现队列</p><p>​        解法类型：</p><p>​                单调栈</p><p>​                双指针</p><p>​                双栈</p><p>​                观察并推导出数学公式</p><p>​                语言自带工具类</p><p>​            </p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>​                滑动窗口</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>​            注意：Deque同时具有双端队列的性质</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​            优先队列和堆</p><h2 id="优化算法的方法"><a href="#优化算法的方法" class="headerlink" title="优化算法的方法"></a>优化算法的方法</h2><p>​            二分法？？</p><p>​            </p><p>​                </p><p>​         </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>壁纸-无水印</title>
      <link href="/51748.html"/>
      <url>/51748.html</url>
      
        <content type="html"><![CDATA[<h2 id="从网站获取"><a href="#从网站获取" class="headerlink" title="从网站获取"></a>从网站获取</h2><p><a href="https://bing.ioliu.cn/" target="_blank" rel="noopener">历史必应</a></p><p><a href="http://lab.mkblog.cn/wallpaper/" target="_blank" rel="noopener">mkblog</a></p><p><a href="https://github.com/GallonHu/pic">github_GallonHu</a></p><h2 id="手动获取"><a href="#手动获取" class="headerlink" title="手动获取"></a>手动获取</h2><p>（1）打开必应官方网站</p><p>（2）鼠标右击图片，选择检查选项</p><p>（3） 找到Sources选项</p><p>（4）点击top栏目里最下方选项就能看到图片</p><p>（5）鼠标右击图片，选择保存</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo文章插图显示问题-个人测试有效</title>
      <link href="/7663.html"/>
      <url>/7663.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法一-GitHub路径"><a href="#方法一-GitHub路径" class="headerlink" title="方法一 GitHub路径"></a>方法一 GitHub路径</h2><p>​    （1）在Hexo下的.config.yml中设置post_asset_folder选项为true</p><p>​    （2）在git bash命令窗口下 使用hexo n “你的待插入图片的新建文章名称” 来生成新的md文件，在这个新建文件的同级目录下，会产生同名的文件夹。</p><p>​    （3）需要在新建md文件插入图片时，先把图片复制到（2）中的同名文件夹中</p><p>​    （4）按照花括号中的格式来插入图片<code>！[图片描述](待插入图片github中的路径)</code>。若没有路径，可先在git bash 上使用hexo相关命令提交文章来产生。例如，我上传文章的图片的路径为{<code>！[JVM 虚拟机运行时数据区](/17374/JVM.png)</code>}，如下图：</p><p>​                        <img src="/7663/github_path.png" alt="图片在github中的路径"></p><p>​                        <img src="/7663/Hexo_pic.png" alt="图片的在代码中显示的路径"></p><p>​     实际上，图片通过这种方法能正常显示是因为，图片通过这种上传方式已经存在于github上，再通过这种引用图片的格式<code>！[图片描述](待插入图片github中的路径)</code>，来显示图片。</p><h2 id="方法二-图床"><a href="#方法二-图床" class="headerlink" title="方法二 图床"></a>方法二 图床</h2><p>​        使用图床获取url链接来显示图片</p><p>​        参考方法：<a href="https://www.dazhuanlan.com/2019/09/26/5d8cbd5d55654/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/09/26/5d8cbd5d55654/</a></p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/17374.html"/>
      <url>/17374.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解JAVA虚拟机-第三版"><a href="#深入理解JAVA虚拟机-第三版" class="headerlink" title="深入理解JAVA虚拟机 (第三版)"></a>深入理解JAVA虚拟机 (第三版)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/17374/JVM.png" alt="JVM 虚拟机运行时数据区"></p><p>《深入理解JAVA虚拟》第三版主要围绕着上图来叙述，分为五大部分：</p><p>​        （1）JAVA发展历史：涉及JVM自诞生的版本到目前的版本的发展历程，其中，有讲述为何虚拟机会发生这样的演变，以及与其他类型虚拟机的的关系，并对虚拟机进行了展望。</p><p>​        （2）自动内存管理（运行时数据区）：涉及内存管理的异常，像内存溢出异常、OutOfMemory Error等，垃圾收集器，内存分配策略，故障处理方法与工具，调优方法。</p><p>​           (3）JVM执行子系统（执行）：类文件结构；JVM类加载的机制；字节码执行引擎；</p><p>​        （4）代码编译和优化；前端编译和优化（JAVA语法糖等）；后端编译与优化（即时编译、编译器优化技术-<strong>方法内联、逃逸分析</strong>等）</p><p>​        （5）高效并发：如何实现并发（JAVA内存模型）；如何高效实现并发（锁的介绍、<strong>锁优化</strong>-锁粗化、锁自旋、锁偏向等等）</p><p>若需要《深入理解JAVA虚拟机》第三版pdf，可发邮件至###qhuang724@gmail.com###（发送时去掉#）</p><p>​            </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transfer Learning</title>
      <link href="/8787.html"/>
      <url>/8787.html</url>
      
        <content type="html"><![CDATA[<h1 id="跨领域情感分析"><a href="#跨领域情感分析" class="headerlink" title="跨领域情感分析"></a>跨领域情感分析</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><pre><code>近几年的综述</code></pre><h2 id="相关研究者"><a href="#相关研究者" class="headerlink" title="相关研究者"></a>相关研究者</h2><h3 id="国内研究者"><a href="#国内研究者" class="headerlink" title="国内研究者"></a>国内研究者</h3><p><a href="https://www.zhihu.com/people/jindongwang/activities" target="_blank" rel="noopener">迁移学习手册——王晋东</a></p><h3 id="国外研究者"><a href="#国外研究者" class="headerlink" title="国外研究者"></a>国外研究者</h3>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugs</title>
      <link href="/30574.html"/>
      <url>/30574.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://chrischen0405.github.io/2018/11/21/post20181121-2/" target="_blank" rel="noopener">hexo发布文章报错can not read a block mapping entry</a></p><h1 id="bert"><a href="#bert" class="headerlink" title="bert"></a>bert</h1><p><a href="https://blog.csdn.net/yangdan1025/article/details/103293891" target="_blank" rel="noopener">Bert在Win10启动server TypeError: cannot unpack non-iterable NoneType object</a></p>]]></content>
      
      
      <categories>
          
          <category> Bugs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm per day</title>
      <link href="/29461.html"/>
      <url>/29461.html</url>
      
        <content type="html"><![CDATA[<h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><h3 id="two-sum"><a href="#two-sum" class="headerlink" title="two-sum"></a>two-sum</h3><pre><code>暴力解法：时间复杂度为O（n^2）运用HashMap：时间复杂度为O（1），相比较于暴力解法，在数据规模较大的时候，还是有时间上的优势的。关于containsKey()方法，根据某种哈希算法，直接定位所要的元素，也就是说，这个查找的方法的时间复杂度最好为O（1），若没有直接找到，存储方式变为红黑树，查询复杂度为O（lgn），而并非O（n^2）。</code></pre><p>参考：<a href="https://blog.csdn.net/qingtian_1993/article/details/80763381" target="_blank" rel="noopener">containsKey()方法的复杂度为何为O（1）</a></p><h3 id="mini-parser"><a href="#mini-parser" class="headerlink" title="mini-parser"></a>mini-parser</h3><pre><code>相似题目 flatten-nested-list-iterator</code></pre><h2 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h2><h3 id="next-greater-element-ii"><a href="#next-greater-element-ii" class="headerlink" title="next-greater-element-ii"></a>next-greater-element-ii</h3><pre><code>    暴力解法；    运用栈；        在解决循环列表的时候，可以用循环链表、列表中每个数重复两次（可能会有取余操作）、可以用三个for循环（暴力解法）。        题目中使用栈作为相邻有先后顺寻的元素的存储介质，利用栈的特性，方便得到结果，时间复杂度为O(1),空间复杂度为O（1）。</code></pre><h3 id="biao-qian-yan-zheng-qi-by-leetcode"><a href="#biao-qian-yan-zheng-qi-by-leetcode" class="headerlink" title="biao-qian-yan-zheng-qi-by-leetcode"></a>biao-qian-yan-zheng-qi-by-leetcode</h3><pre><code>    这个题目先放放。</code></pre><h3 id="exclusive-time-of-functions"><a href="#exclusive-time-of-functions" class="headerlink" title="exclusive-time-of-functions"></a>exclusive-time-of-functions</h3><pre><code>    利用栈来做，类似于中缀表达式求值</code></pre><h3 id="baseball-game"><a href="#baseball-game" class="headerlink" title="baseball-game"></a>baseball-game</h3><pre><code>    利用栈的先进后出的特点来操作数据，类似于中缀表达式求值</code></pre><h2 id="day-3"><a href="#day-3" class="headerlink" title="day 3"></a>day 3</h2><h3 id="number-of-atoms"><a href="#number-of-atoms" class="headerlink" title="number-of-atoms"></a>number-of-atoms</h3><pre><code>    利用栈和map来解析化学表达式，其中得注意字符和数字处理的API，使用java.util.*来处理排序（Arrays）</code></pre><h2 id="day-4"><a href="#day-4" class="headerlink" title="day 4"></a>day 4</h2><h3 id="asteroid-collision"><a href="#asteroid-collision" class="headerlink" title="asteroid-collision"></a>asteroid-collision</h3><pre><code>    利用一个栈来的特点来操作数据，而不是用两个栈</code></pre><h3 id="dailyTemperatures"><a href="#dailyTemperatures" class="headerlink" title="dailyTemperatures"></a>dailyTemperatures</h3><pre><code>    利用栈的特点来操作数据，比暴力解法要快得多</code></pre><h2 id="day-5"><a href="#day-5" class="headerlink" title="day 5"></a>day 5</h2><h3 id="backspace-string-compare"><a href="#backspace-string-compare" class="headerlink" title="backspace-string-compare"></a>backspace-string-compare</h3><pre><code> 利用栈的特点来操作数据</code></pre><h3 id="score-of-parentheses"><a href="#score-of-parentheses" class="headerlink" title="score-of-parentheses"></a>score-of-parentheses</h3><pre><code>    第一种比较容易想到的方法是利用栈来操作数据，类似于中缀表达式求值。（O(N),O(N)）    第二种方法：当仔细分析对结果有影响的因素时，会发现不同深度的()的得分会实质性地作用于最终的得分，其他的括号要么是累加，要么是将分数乘以2。进一步抽象，会发现2^x求和（x为()的深度）会是最终的结果（如果输入只有括号）。此时，并没有采用栈，而是发现了求最后结果的过程中，抽象出了数学表达式，利用数学表达式来求最后的结果。(O(N),O(1))    第三种方法：采用分治策略，组成最后的分的结果的要素分别相加求和。以平衡括号为字符串分解的点，若以左括号为1，右括号为-1，当遍历字符串时，S累加为0时，则说明有平衡括号()。(O(N^2),O(1))</code></pre><h3 id="decoded-string-at-index"><a href="#decoded-string-at-index" class="headerlink" title="decoded-string-at-index"></a>decoded-string-at-index</h3><pre><code>在影响最后结果的因素中，求出字符串结果不是必要的，反而，求出字符串变化后的size，能够实质性地助力求解最后地结果。另一方面，在字符串变化的过程中，仔细观察，会发现，当节码字符串长度为size的词重复多次时，索引K的结果与K/size的结果一致。正是这两个特点，就能够对暴力解法在时间复杂度或空间复杂度上作优化。这也是一例没有采用栈结构来求解的方法，直接运用求值过程中良好的特点来优化求值过程。（O(N),O(1)）</code></pre><h3 id="maximum-frequency-stack"><a href="#maximum-frequency-stack" class="headerlink" title="maximum-frequency-stack"></a>maximum-frequency-stack</h3><pre><code>官方代码其中一行：group.computeIfAbsent(f, z-&gt; new Stack()).push(x);(O(1),O(N))</code></pre><h3 id="online-stock-span"><a href="#online-stock-span" class="headerlink" title="online-stock-span"></a>online-stock-span</h3><pre><code>单调栈（栈中的数据非严格单调递减）求出小于或等于今天价格的最大连续日数等价于求出最近的一个大于今日价格的日子（O（N）,O(N)）</code></pre><h3 id="sum-of-subarray-minimums"><a href="#sum-of-subarray-minimums" class="headerlink" title="sum-of-subarray-minimums"></a>sum-of-subarray-minimums</h3><pre><code>    思路一：所有满足 `A[j]` 为最右且最小的元素的子序列个数 `#(j)`，那么结果就是 `sum #(j) * A[j]`.（O(N),O(N)）    [c++ 单调栈](https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/cdan-diao-zhan-by-qwqcxh/)    思路二：想法是每当我们增加 `j`，这些最小值可能会有关联，事实上，`min(A[i:j+1]) = min(A[i:j], A[j+1])`。采用栈的数据结构。（O(N),O(N)）    动态规划：    暴力解法：</code></pre><h3 id="odd-even-jump"><a href="#odd-even-jump" class="headerlink" title="odd-even-jump"></a>odd-even-jump</h3><h3 id="check-if-word-is-valid-after-substitutions"><a href="#check-if-word-is-valid-after-substitutions" class="headerlink" title="check-if-word-is-valid-after-substitutions"></a>check-if-word-is-valid-after-substitutions</h3><pre><code>class Solution {     public boolean isValid(String S) {         while(S.contains(&quot;abc&quot;)) {          S = S.replaceAll(&quot;abc&quot;,&quot;&quot;);          }     return S.equals(&quot;&quot;);     } }</code></pre><h3 id="next-greater-node-in-linked-list"><a href="#next-greater-node-in-linked-list" class="headerlink" title="next-greater-node-in-linked-list"></a>next-greater-node-in-linked-list</h3><pre><code>采用单调栈暴力解法[单调栈解法的其他题目](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/solution/python-dan-diao-zhan-by-jackwener/)</code></pre><h2 id="day-6"><a href="#day-6" class="headerlink" title="day 6"></a>day 6</h2><h3 id="longest-well-performing-interval"><a href="#longest-well-performing-interval" class="headerlink" title="longest-well-performing-interval"></a>longest-well-performing-interval</h3><pre><code>这个题目等下做</code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github/gitee/gitlab+optimization</title>
      <link href="/65248.html"/>
      <url>/65248.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="Hexo-GitHub"><a href="#Hexo-GitHub" class="headerlink" title="Hexo+GitHub"></a>Hexo+GitHub</h3><p>1.<a href="https://juejin.im/post/5dd2e898e51d45400206a466" target="_blank" rel="noopener">juejin.im/post/5dd2e898e51d45400206a466</a><br>2.<a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">godweiyang.com/2018/04/13/hexo-blog/</a><br>3.<a href="https://blog.sky03.cn/posts/41882.html" target="_blank" rel="noopener">blog.sky03.cn/posts/41882.html</a><br>4.<a href="https://www.cnblogs.com/bndong/p/9947729.html" target="_blank" rel="noopener">www.cnblogs.com/bndong/p/9947729.html</a><br>hexo+gitlab、hexo+gitee类似</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>1.<a href="https://blog.sky03.cn/posts/42790.html#toc-heading-15" target="_blank" rel="noopener">blog.sky03.cn/posts/42790.html#toc-heading-15</a><br>2.<a href="https://www.jianshu.com/p/a664545f155c" target="_blank" rel="noopener">jianshu.com/p/a664545f155c</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo文档</a><br>2.<a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">MarkDown文档</a></p><h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><p><a href="https://blog.csdn.net/banjw_129/article/details/82261165" target="_blank" rel="noopener">hexo +gitee pages 样式无法加载</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tool</title>
      <link href="/61453.html"/>
      <url>/61453.html</url>
      
        <content type="html"><![CDATA[<h2 id="语言文档"><a href="#语言文档" class="headerlink" title="语言文档"></a>语言文档</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.zealdocs.org" target="_blank" rel="noopener">Zeal</a> ：脱机文档       浏览器，包含196中语言API文档，支持Windows、Linux和macOS<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zealusercontributions.now.sh/" target="_blank" rel="noopener">Zeal-docsets-xml</a> ：zeal 的docsets，采用xml引入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.kapeli.com" target="_blank" rel="noopener">Dash</a>：适用于Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.devdocs.com" target="_blank" rel="noopener">DevDocs</a>：    在快速，有条理和可搜索的界面中结合许多个API文档，可以在移动设备上离线运行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://en.cppreference.com/w" target="_blank" rel="noopener">C/C++</a>：C/C++ API文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://docs.oracle.com/en/java" target="_blank" rel="noopener">Java</a>：Java API文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">On Java 8</a>：JAVA编程思想第五版（On Java 8）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://studygolang.com/pkgdoc" target="_blank" rel="noopener">Go</a>：Go API 文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://ww2.mathowrks.cn/help/matlab/index.html" target="_blank" rel="noopener">MATLAB</a>：MATLAB API 文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank" rel="noopener">HTML</a>：HTML API 文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://redisdoc.com" target="_blank" rel="noopener">Redis</a>：Redis API 文档</p><h2 id="在线平台"><a href="#在线平台" class="headerlink" title="在线平台"></a>在线平台</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://leetcode-cn.com/" target="_blank" rel="noopener">Leetcode</a>：算法练习等，编程能力提升的加油站<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.topcoder.com/" target="_blank" rel="noopener">Topcoder</a>：程序竞赛网站，适合一些高端的或者搞ACM的，也会举办一些比赛<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.lintcode.com/" target="_blank" rel="noopener">Leetcode</a>：中文版的leetcode，编程能力提升的加油站<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://acmclub.cn/" target="_blank" rel="noopener">NEUQ OJ</a>：在线的判题平台<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.nowcoder.com/contestRoom" target="_blank" rel="noopener">牛客网</a>：IT题库、牛客热评、面经、内推码等</p><h2 id="高校OJ"><a href="#高校OJ" class="headerlink" title="高校OJ"></a>高校OJ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://poj.org/" target="_blank" rel="noopener">POJ</a>：北京大学程序在线评测系统</p><h2 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a>站长工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://tool.chinaz.com/" target="_blank" rel="noopener">站长工具</a>：SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://linshiyouxiang.net/" target="_blank" rel="noopener">临时邮箱</a>：匿名注册不常用的网站/论坛，保护隐私免骚扰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a>：SM 免费图床，每个文件最大支持 5MB<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://namebeta.com/" target="_blank" rel="noopener">NnameBeta</a>：国际域名搜索、域名注册、国别域名注册、域名比价等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.domcomp.com/" target="_blank" rel="noopener">Domcomp</a>：域名比价<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tool.lusongsong.com/seo/" target="_blank" rel="noopener">SEO 外链工具</a>：网站自动化宣传机器/免费的超级外链工具可批量增加外链<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接码平台</p><p>​            <a href="http://z-sms.com/" target="_blank" rel="noopener">http://z-sms.com/</a><br>​            <a href="https://yunduanxin.net" target="_blank" rel="noopener">https://yunduanxin.net</a><br>​            <a href="http://z-sms.com/" target="_blank" rel="noopener">http://z-sms.com/</a><br>​            <a href="https://www.becmd.com/" target="_blank" rel="noopener">https://www.becmd.com/</a><br>​            <a href="https://www.cnwml.com/" target="_blank" rel="noopener">https://www.cnwml.com/</a><br>​            <a href="http://www.z-sms.com/" target="_blank" rel="noopener">http://www.z-sms.com/</a><br>​            <a href="http://receivefreesms.com/" target="_blank" rel="noopener">http://receivefreesms.com/</a><br>​            <a href="https://www.yinsixiaohao.com/" target="_blank" rel="noopener">https://www.yinsixiaohao.com/</a><br>​            <a href="https://sms.bilulanlv.com" target="_blank" rel="noopener">https://sms.bilulanlv.com</a><br>​            <a href="http://www.pdflibr.com" target="_blank" rel="noopener">www.pdflibr.com</a><br>​            <a href="">smsonline.ga</a><br>​            <a href="">smsreceivefree.com</a><br>​            <a href="http://www.receive-sms-online.info" target="_blank" rel="noopener">www.receive-sms-online.info</a><br>​            <a href="">receiveasms.com</a><br>​            <a href="">receivefreesms.com</a><br>​            <a href="http://www.becmd.com" target="_blank" rel="noopener">www.becmd.com</a><br>​            <a href="">sms-online.co</a><br>​            <a href="https://sms.bilulanlv.com">https://sms.bilulanlv.com</a><br>​            <a href="https://www.receivingsms.com" target="_blank" rel="noopener">https://www.receivingsms.com</a><br>​            <a href="https://www.blacktel.io" target="_blank" rel="noopener">https://www.blacktel.io</a><br>​            <a href="http://www.spoofbox.com" target="_blank" rel="noopener">http://www.spoofbox.com</a><br>​            <a href="https://sms.ndtan.net" target="_blank" rel="noopener">https://sms.ndtan.net</a><br>​            <a href="http://onlinesim.ru" target="_blank" rel="noopener">http://onlinesim.ru</a><br>​            <a href="https://www.twilio.com" target="_blank" rel="noopener">https://www.twilio.com</a><br>​            <a href="https://www.pdflibr.com" target="_blank" rel="noopener">https://www.pdflibr.com</a><br>​            <a href="http://sms.sellaite.com" target="_blank" rel="noopener">http://sms.sellaite.com</a><br>​            <a href="http://receive-sms-online.com" target="_blank" rel="noopener">http://receive-sms-online.com</a><br>​            <a href="https://www.freeonlinephone.org" target="_blank" rel="noopener">https://www.freeonlinephone.org</a><br>​            <a href="https://www.receivesmsonline.net" target="_blank" rel="noopener">https://www.receivesmsonline.net</a><br>​            <a href="http://receivefreesms.com" target="_blank" rel="noopener">http://receivefreesms.com</a><br>​            <a href="https://receive-sms.com" target="_blank" rel="noopener">https://receive-sms.com</a><br>​            <a href="https://sms-online.co/receive-free-sms" target="_blank" rel="noopener">https://sms-online.co/receive-free-sms</a><br>​            <a href="https://smsnumbersonline.com" target="_blank" rel="noopener">https://smsnumbersonline.com</a><br>​            <a href="https://receive-a-sms.com" target="_blank" rel="noopener">https://receive-a-sms.com</a><br>​            <a href="https://www.receive-sms-online.info" target="_blank" rel="noopener">https://www.receive-sms-online.info</a><br>​            <a href="https://smsreceivefree.com" target="_blank" rel="noopener">https://smsreceivefree.com</a><br>​            <a href="https://www.laiduqu.com" target="_blank" rel="noopener">https://www.laiduqu.com</a><br>​            <a href="https://www.attackmen.com/" target="_blank" rel="noopener">https://www.attackmen.com/</a><br>​            <a href="https://shimo.im/docs/BQ6UHIDt9ekOQHyv" target="_blank" rel="noopener">https://shimo.im/docs/BQ6UHIDt9ekOQHyv</a></p><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tool.lu/" target="_blank" rel="noopener">Coder 工具箱</a>：站长工具、代码格式化、压缩、加密、解密、下载链接转换等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tool.oschina.net/" target="_blank" rel="noopener">在线工具 - OSCHINA.NET社区</a>：常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tools.ly522.com/" target="_blank" rel="noopener">记磊工具箱</a>：Dns检测、CSS格式化、超级Ping、端口扫描等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://tool.mkblog.cn" target="_blank" rel="noopener">孟坤工具箱</a>：css一键美化、文本差异比较、代码高亮等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.planetb.ca/syntax-highlight-word" target="_blank" rel="noopener">Syntax Highlight</a>：Syntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://qiao.github.io/PathFinding.js/visual/" target="_blank" rel="noopener">动画展示——路径搜索算法</a>：Syntax Highlight Code In Word Documents，动画展示各种路径搜索算法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/justjavac/free-programming-books-zh_CN">编程类中文书籍</a>：Syntax Highlight Code In Word Documents，免费计算机编程类中文书籍<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.easeus.com/" target="_blank" rel="noopener">磁盘分区软件</a>：EaseUS Partition Master——磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间</p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.pdfdo.com/" target="_blank" rel="noopener">文件转换器</a>：在线文件转换工具<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://convertio.co" target="_blank" rel="noopener">Convertio</a>：在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cn.office-converter.com" target="_blank" rel="noopener">Office-Converter</a>：免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.uupoop.com" target="_blank" rel="noopener">PS</a>：在线PS</p><h2 id="设计素材"><a href="#设计素材" class="headerlink" title="设计素材"></a>设计素材</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">Iconfont</a>：阿里巴巴矢量图标库，有矢量图标下载、在线存储、格式转换等功能<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.flaticon.com/" target="_blank" rel="noopener">Flaticon</a>：海量扁平化免费的图标库<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://icons8.com/" target="_blank" rel="noopener">icons8</a>：独特系统平台风格、独特的web图标库以及音乐</p><h2 id="手机刷机"><a href="#手机刷机" class="headerlink" title="手机刷机"></a>手机刷机</h2><p>刷机工具：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猎人大师（淘宝）；OPPO售后解锁恢复专用软件包；<br>网站：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="www.rom100.com">万维网</a><br>对于近1-2年的新机型，可能一般的解锁工具不太行，像解oppo reno 的屏幕锁，要么售后，要么邮寄找人解锁</p><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亿寻（湖南版；标准版），速度是杠杠的<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chrome插件+IDM，平时下载一些热门资源，速度和亿寻差不多，就是配置稍微有点麻烦<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://bbs.vipfenxiang.com/thread-52542-1-1.html" target="_blank" rel="noopener">vip分享网</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“淘一下”，基本6元左右一个月<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;收费软件：速盘（按流量收费）；新极品(6.5元/月合租百度网盘超级会员账号);</p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>​        <a href="http://bbs.xiaobaipan.com/forum.php?mod=viewthread&tid=13576&extra=" target="_blank" rel="noopener">计算机书籍</a></p><p>​                </p><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.liuyao-blog.cn" target="_blank" rel="noopener">liuyao</a>：Box中有许多个人手机的工具<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://godweiyang.com/" target="_blank" rel="noopener">WeiYang</a>：NLP、算法分享<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://flyrie.top/2018/10/20/Pip_No_Attribute_Main/" target="_blank" rel="noopener">田间小路</a>：ML、DL</p><h2 id="Software-PJ"><a href="#Software-PJ" class="headerlink" title="Software-PJ"></a>Software-PJ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.chinapyg.com" target="_blank" rel="noopener">飘云阁</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://masuit.com/1230/history" target="_blank" rel="noopener">懒得勤快</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.gopojie.net/" target="_blank" rel="noopener">GoPoJie</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.haozi666.com/" target="_blank" rel="noopener">耗子修改</a><br>​        <a href="http://www.carrotchou.blog/" target="_blank" rel="noopener">胡萝卜周</a><br>​        <a href="https://www.ypojie.com/" target="_blank" rel="noopener">易破解</a><br>​        <a href="https://bbs.pediy.com/thread-13361.htm" target="_blank" rel="noopener">国外破解网站大全</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/16107.html"/>
      <url>/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
