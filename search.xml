<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程序员面试金典-6-Ch</title>
      <link href="/41175.html"/>
      <url>/41175.html</url>
      
        <content type="html"><![CDATA[<p>行为面试题</p><table><thead><tr><th><strong>常见问题</strong></th><th><strong>项目 1</strong></th><th><strong>项目 2</strong></th><th><strong>项目 3</strong></th></tr></thead><tbody><tr><td>遇到过的挑战</td><td></td><td></td><td></td></tr><tr><td>遭遇过的滑铁卢</td><td></td><td></td><td></td></tr><tr><td>最享受什么</td><td></td><td></td><td></td></tr><tr><td>如何体现领导力</td><td></td><td></td><td></td></tr><tr><td>如何处理冲突</td><td></td><td></td><td></td></tr><tr><td>有哪些可改进之处</td><td></td><td></td><td></td></tr></tbody></table><p>确保你有1至3个项目可以拿得出手，并能就其细节侃侃而谈</p><p>自我介绍：</p><p>​    </p><p><strong>核心数据结构、算法及概念</strong></p><table><thead><tr><th><strong>数据结构</strong></th><th><strong>算法</strong></th><th><strong>概念</strong></th></tr></thead><tbody><tr><td>链表</td><td>广度优先搜索</td><td>位操作</td></tr><tr><td>树、单词查找树、图</td><td>深度优先搜索</td><td>内存（堆和栈）</td></tr><tr><td>栈和队列</td><td>二分查找</td><td>递归</td></tr><tr><td>堆</td><td>归并排序</td><td>动态规划</td></tr><tr><td>向量/数组列表</td><td>快排</td><td>大<img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif" alt="O"> 时间及空间</td></tr><tr><td>散列表</td><td></td><td></td></tr></tbody></table><p>对于上述各项题目，务必掌握它们的具体用法、实现方法、应用场景以及空间和时间复杂度。</p><p>一种不错的方法就是练习如何实现数据结构和算法（先在纸上，然后在电脑上）。你会在这个过程中学到数据结构内部是如何工作的，这对很多面试而言都是不可或缺的。</p><p>你错过上面那段了吗？千万不要错过，这非常重要。如果对上面列出的某个数据结构和算法感觉不能运用自如，就从头开始练习吧。</p><p>其中，散列表是必不可少的一个题目。对这个数据结构，务必要胸有成竹。</p><p>涉及可扩展性或者内存排序限制等问题，同时，这张表可以拿来做速算</p><table><thead><tr><th><strong>2**</strong>的幂**</th><th><strong>准确值（*X* ）</strong></th><th><strong>近似值</strong></th><th><strong><em>X\</em></strong> <strong>字节转换成MB、GB等</strong></th></tr></thead><tbody><tr><td>7</td><td>128</td><td></td><td></td></tr><tr><td>8</td><td>256</td><td></td><td></td></tr><tr><td>10</td><td>1024</td><td>一千</td><td>1 K</td></tr><tr><td>16</td><td>65 536</td><td></td><td>64 K</td></tr><tr><td>20</td><td>1 048 576</td><td>一百万</td><td>1 MB</td></tr><tr><td>30</td><td>1 073 741 824</td><td>十亿</td><td>1 GB</td></tr><tr><td>32</td><td>4 294 967 296</td><td></td><td>4 GB</td></tr><tr><td>40</td><td>1 099 511 627 776</td><td>一万亿</td><td>1 TB</td></tr></tbody></table><p>BUD优化：瓶颈、无用功、重复性工作</p><p>你一旦有了蛮力法，就应该努力优化该方法。以下技巧就有了用武之地。</p><p>(1) 寻找未使用的信息。你的面试官告诉过你数组是有序的吗？你如何利用这些信息？</p><p>(2) 换个新例子。很多时候，换个不同的例子会让你思路畅通，看到问题模式所在。</p><p>(3) 尝试错误解法。低效的例子能帮你看清优化的方法，一个错误的解法可能会帮助你找到正确的方法。比方说，如果让你从一个所有值可能都相等的集合中生成一个随机值。一个错误的方法可能是直接返回半随机值。可以返回任何值，但是可能某些值概率更大，进而思考为什么解决方案不是完美随机值。你能调整概率吗？</p><p>(4) 权衡时间、空间。有时存储额外的问题相关数据可能对优化运行时间有益。</p><p>(5) 预处理信息。有办法重新组织数据（排序等）或者预先计算一些有助于节省时间的值吗？</p><p>(6) 使用散列表。散列表在面试题中用途广泛，你应该第一个想到它。</p><p>(7) 考虑可想象的极限运行时间（详见7.9节）。</p><p>在蛮力法基础上试试这些技巧，寻找BUD的优化点。</p><p><strong>测试</strong></p><p>在现实中，不经过测试就不会签入代码；在面试中，未经过测试同样不要“提交”。</p><p>测试代码有两种办法：一种聪明的，一种不那么聪明的。</p><p>许多求职者会用最开始的例子来测试代码。那样做可能会发现一些bug，但同样会花很长时间。手动测试很慢。如果设计算法时真的使用了一个大而好的例子，那么测试时间就会很长，但最后可能只在代码末尾发现一些小问题。</p><p>你应该尝试以下方法。</p><p>(1) 从概念测试着手。概念测试就是阅读和分析代码的每一行。像代码评审那样思考，在心中解释每一行代码的含义。</p><p>(2) 跳着看代码。重点检查类似x = length-2 的行。对于for 循环，要尤为注意初始化的地方，比如i = 1 。当你真的去检查时，就很容易发现小错误。</p><p>(3) 热点代码。如果你编程经验足够丰富的话，就会知道哪些地方可能出错。递归中的基线条件、整数除法、二叉树中的空节点、链表迭代中的开始和结束，这些要反复检查才行。</p><p>(4) 短小精悍的用例。接下来开始尝试测试代码，使用真实、具体的用例。不要使用大而全的例子，比如前面用来开发算法的8元素数组，只需要使用3到4个元素的数组就够了。这样也可以发现相同的bug，但比大的快多了。</p><p>(5) 特殊用例。用空值、单个元素、极端情况和其他特殊情况检测代码。</p><p>发现了bug（很可能会）就要修复。但注意不要贸然修改。仔细斟酌，找出问题所在，找到最佳的修改方案，只有这样才能动手。</p><p>优化和解体技巧</p><p>​     不事先带入专业的知识，试着把它当作日常生活问题来解决</p><p>​     从约束少的，个例出发，再推广到适应多种情况的解决方法</p><p>​     由基础例子出发推广得到解决办法</p><p>​     遍历数据结构，挑选个合适的，说不定就有了个较好的解决办法</p><p>​     想象问题的极限</p><p>好的代码</p><p>​     多使用数据结构</p><p>​     适当代码复用</p><p>​     模块化</p><p>​     灵活性和通用性</p><p>​     错误检查</p><p>​          </p><p>数据结构</p><p>​     数组与字符串</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_160" target="_blank" rel="noopener">9.1　数组与字符串</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_161" target="_blank" rel="noopener">9.1.1　散列表</a></p><p>​          散列表是一种通过将键（key）映射为值（value）从而实现快速查找的数据结构。</p><p>​          使用一个链表构成的数组与一个散列函数来实现散列表</p><p>​          通过平衡二叉搜索树来实现散列表。该方法的查找时间是O(\log N) 。该方法的好处是用到的空间可能更少，因为我们不再需要分配一个大数组。还可以按照键的顺序进行迭代访问，在某些时候这样做很有用。</p><p>​          散列表冲突解决方案</p><p>​              </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_162" target="_blank" rel="noopener">9.1.2　ArrayList与可变长度数组</a></p><p>​          这是面试中的一个基础数据结构。无论使用何种编程语言，都要确保能够熟练运用动态数组（链表）。</p><p>​          最终扩容：复制n/2 个元素</p><p>之前的扩容：复制n/4 个元素</p><p>之前的扩容：复制n/8 个元素</p><p>​     </p><p>之前的扩容：复制n/16 个元素</p><p>……</p><p>第二次扩容：复制2个元素</p><p>第一次扩容：复制1个元素</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_163" target="_blank" rel="noopener">9.1.3　StringBuilder</a></p><p>​          StringBuilder 可以避免普通拼接字符串方法效率低的问题。它会直接创建一个足以容纳所有字符串的可变长度数组，等到拼接完成才将这些字符串转成一个字符串</p><p>​          拉宾-卡普（Rabin-Karp）子串查找</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_164" target="_blank" rel="noopener">9.2　链表</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_165" target="_blank" rel="noopener">9.2.1　创建链表</a></p><p>​          链表是一种用于表示一系列节点的数据结构。在单向链表中，每个节点指向链表中的下一个节点。而在双向链表中，每个节点同时具备指向前一个节点和后一个节点的指针</p><p>​          与数组不同的是，无法在常数时间复杂度内访问链表的一个特定索引。这意味着如果要访问链表中的第K 个元素，需要迭代访问K 个元素。</p><p>​          </p><p>链表的好处在于你可以在常数时间复杂度内加入和删除元素。这对于某些特定的程序大有用处</p><p>切记：在面试中遇到链表题时，务必弄清楚它到底是单向链表还是双向链表</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_166" target="_blank" rel="noopener">9.2.2　删除单向链表中的节点</a></p><p>​          (1) 检查空指针；(2) 必要时更新表头（head）或表尾（tail）指针。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_167" target="_blank" rel="noopener">9.2.3　“快行指针”技巧</a></p><p>​          </p><p>​          </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_168" target="_blank" rel="noopener">9.2.4　递归问题</a></p><p>​          许多链表问题都要用到递归。解决链表问题碰壁时，不妨试试递归法能否奏效。这里暂时不会深入探讨递归，后面会有专门章节予以讲解。</p><p>当然，还需注意递归算法至少要占用O(n) 的空间，其中n 为递归调用的层数。实际上，所有递归算法都可以 转换成迭代法，只是后者实现起来可能要复杂得多</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_169" target="_blank" rel="noopener">9.3　栈与队列</a></p><p>​     熟练掌握数据结构的基本原理，栈与队列问题处理起来要容易得多。当然，有些问题也可能相当棘手。部分问题不过是对基本数据结构略作调整，其他问题则要难得多</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_170" target="_blank" rel="noopener">9.3.1　实现一个栈</a></p><p>​     与数组不同的是，栈无法在常数时间复杂度内访问第i 个元素。但是，因为栈不需要在添加和删除操作时移动元素，所以可以在常数时间复杂度内完成此类操作。</p><p>​     下面给出了栈的简单实现代码。注意，如果只从链表的一端添加和删除元素，栈也可以用链表实现。</p><p>​     对于某些递归算法，栈通常大有用处。有时，你需要在递归时把临时数据加入到栈中，在回溯时（例如，在递归判断失败时）再删除该数据。栈是实现这类算法的一种直观方法。</p><p>当使用迭代法实现递归算法时，栈也可派上用场。（这是一个很好的练习项目。选择一个简单的递归算法并用迭代法实现该算法。）</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_171" target="_blank" rel="noopener">9.3.2　实现一个队列</a></p><p>​     队列也可以用链表实现。事实上，只要元素是从链表的相反的两端添加和删除的，链表和队列本质上就是一样的。</p><p>​     更新队列当中第一个和最后一个节点很容易出错，请务必再三确认。</p><p>队列常用于广度优先搜索或缓存的实现中。</p><p>例如，在广度优先搜索中，我们使用队列来存储需要被处理的节点。每处理一个节点时，就把其相邻节点加入到队列的尾端。这使得我们可以按照发现节点的顺序处理各个节点。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_172" target="_blank" rel="noopener">9.4　树与图</a></p><p>​     能够游刃有余地从无到有实现树或图，这是求职者必不可少的一种技能。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_173" target="_blank" rel="noopener">9.4.1　树的类型</a></p><p>​     9.4.1.1 树与二叉树</p><p>​     9.4.1.2 二叉树与二叉搜索树</p><p>​          二叉搜索树是二叉树的一种，该树的所有节点均需满足如下属性：全部左子孙节点 \leqslant n&lt; 全部右子孙节点。</p><p>​          二叉搜索树对于“相等”的定义可能会略有不同。根据一些定义，该类树不能有重复的值。在其他方面，重复的值将在右侧或者可以在任一侧。所有这些都是有效的定义，但你应该向面试官澄清该问题。</p><p>​     9.4.1.3 平衡与不平衡</p><p>​          平衡一棵树并不表示左子树和右子树的大小完全相同（如9.4.1.6节中的完美二叉树所示）。思考此类问题的一个方法是，“平衡”树实际上多半意味着“不是非常不平衡”的树。它的平衡性足以确保执行insert 和find 操作可以在O(\log n) 的时间复杂度内完成，但其并不一定是严格意义上的平衡树。</p><p>​          平衡树的两种常见类型是红黑树（11.7节）和AVL树（11.6节）</p><p>​     9.4.1.4 完整二叉树</p><p>​     9.4.1.5 满二叉树</p><p>​     9.4.1.6 完美二叉树</p><p>​          完美二叉树既是完整二叉树，又是满二叉树。所有叶节点都处于同一层，而此层包含最大的节点数。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_174" target="_blank" rel="noopener">9.4.2　二叉树的遍历</a></p><p>​          面试之前，对实现中序、后序和前序遍历，你要做到轻车熟路，其中在面试中最常见的是中序遍历。</p><p>​          9.4.2.1　中序遍历</p><pre><code>1.   void inOrderTraversal(TreeNode node) {2.   if (node != null) {3.    inOrderTraversal(node.left);4.    visit(node);5.    inOrderTraversal(node.right);6.   }7.  }</code></pre><p>​          9.4.2.2　前序遍历</p><pre><code>1.   void preOrderTraversal(TreeNode node) {2.     if (node != null) {3.       visit(node);4.       preOrderTraversal(node.left);5.       preOrderTraversal(node.right);6.     }7.   }</code></pre><p>​          9.4.2.3　后序遍历</p><pre><code>1.   void postOrderTraversal(TreeNode node) {2.     if (node != null) {3.       postOrderTraversal(node.left);4.       postOrderTraversal(node.right);5.       visit(node);6.     }7.   }</code></pre><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_175" target="_blank" rel="noopener">9.4.3　二叉堆（小顶堆与大顶堆）</a></p><p>​          在最小堆中有两个关键操作：insert 和extract_min 。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_176" target="_blank" rel="noopener">9.4.4　单词查找树（前序树）</a></p><p>​          单词查找树（有时被称为前序树）是一种有趣的数据结构。该数据结构多次出现在面试题目中，却在算法教科书中鲜有涉及。     </p><p>​          通常情况下，单词查找树用于存储整个（英文）语言以便于快速前缀查找。虽然散列表可以快速查找字符串是否是有效的单词，但是它不能识别字符串是否是任何有效单词的前缀。单词查找树则可以很快做到这一点。</p><p>​          </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_177" target="_blank" rel="noopener">9.4.5　图</a></p><p>​          简单说来，图是节点与节点之间边的集合。</p><p>​          在编程的过程中，有两种常见方法表示图。</p><p>​          9.4.5.1　邻接链表法</p><p>​          9.4.5.2　邻接矩阵法</p><p>​              由链表（或数组，动态数组）组成的数组（或散列表）也可以存储邻接链表。</p><p>​              可以使用于邻接链表的算法（广度搜索等）同样可以应用于邻接矩阵，但是其效率会有所降低。在邻接链表表示法中，你可以方便地迭代一个节点的相邻节点。在邻接矩阵表示法中，你需要迭代所有节点以便于找出某个节点的所有相邻节点。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_178" target="_blank" rel="noopener">9.4.6　图的搜索</a></p><p>​          值得注意的是，BFS和DFS通常用于不同的场景。如要访问图中所有节点，或者访问最少的节点直至找到想找的节点，DFS一般最为简单。但是，如果我们想找到两个节点中的最短路径（或任意路径），BFS一般说来更加适宜</p><p>9.4.6.2　深度优先搜索DFS</p><p>​               注意，前序和树遍历的其他形式都是一种DFS。主要区别在于，对图实现该算法时，我们必须先检查该节点是否已访问。如果不这么做，就可能陷入无限循环。</p><p>9.4.6.2　广度优先搜索 BFS</p><p>​              它是通过队列实现的。</p><p>​              当面试官要求你实现BFS时，关键在于谨记队列的使用。</p><p>9.4.6.3 双向搜索</p><p>​               双向搜索用于查找起始节点和目的节点间的最短路径。它本质上是从起始节点和目的节点同时开始的两个广度优先搜索。当两个搜索相遇时，我们即找到了一条路径。</p><p>​          </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_179" target="_blank" rel="noopener">9.5　位操作</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_180" target="_blank" rel="noopener">9.5.1　手工位操作</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_181" target="_blank" rel="noopener">9.5.2　位操作原理与技巧</a></p><p>​     </p><table><thead><tr><th>x ^ 0s = x</th><th>x &amp; 0s = 0</th><th>x | 0s = x</th></tr></thead><tbody><tr><td>x ^ 1s = ~x</td><td>x &amp; 1s = x</td><td>x | 1s = 1s</td></tr><tr><td>x ^ x = 0</td><td>x &amp; x = x</td><td>x | x = x</td></tr></tbody></table><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_182" target="_blank" rel="noopener">9.5.3　二进制补码与负数</a></p><p>​     </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_183" target="_blank" rel="noopener">9.5.4　算术右移与逻辑右移</a></p><p>​     有两种类型的右移操作符。算术右移基本上等同于将数除以2。逻辑右移则和我们亲眼看到的移动数位的操作一致。最好可以通过负数进行描述。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_184" target="_blank" rel="noopener">9.5.5　常见位操作：获取与设置数位</a></p><p>​     9.5.5.1　获取数位</p><p>​     9.5.5.2　设置数位</p><p>​     9.5.5.3　清零数位</p><p>​     9.5.5.4　更新数位</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_185" target="_blank" rel="noopener">9.6　数学与逻辑题</a></p><p>​     </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_186" target="_blank" rel="noopener">9.6.1　素数</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_187" target="_blank" rel="noopener">9.6.2　概率</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_188" target="_blank" rel="noopener">9.6.3　大声说出你的思路</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_189" target="_blank" rel="noopener">9.6.4　总结规律和模式</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_190" target="_blank" rel="noopener">9.6.5　略作变通</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_191" target="_blank" rel="noopener">9.6.6　触类旁通</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_192" target="_blank" rel="noopener">9.7　面向对象设计</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_193" target="_blank" rel="noopener">9.7.1　如何解答</a></p><p>​     9.7.1.1　步骤1：处理不明确的地方</p><p>​     9.7.1.2　步骤2：定义核心对象</p><p>​     9.7.1.3　步骤3：分析对象关系</p><p>​     9.7.1.4　步骤4：研究对象的动作</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_194" target="_blank" rel="noopener">9.7.2　设计模式</a></p><p>​     单例设计（singleton）和工厂方法（factory method）设计模式常见于面试</p><p>​     请不要误入歧途——总想着找到某一问题的“正确”设计模式。你需要创建适合于该问题的设计。有时，这样的设计或许是已经存在的模式，但很多情况下并不是</p><p>​     需要说明的是，很多人不喜欢使用单例设计模式，甚至称其为“反模式”。原因之一是该模式会干扰单元测试。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_195" target="_blank" rel="noopener">9.8　递归与动态规划</a></p><p>​     尽管递归问题花样繁多，但题型大都类似。问题属不属于递归问题，就看它是否能分解为子问题。</p><p>当你听到问题的开头是这样的：“设计一个算法计算第n 个……”“列出前n 个……”“实现一个方法，计算所有……”等，那么这基本上就是递归问题</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_196" target="_blank" rel="noopener">9.8.1　解题思路</a></p><p>​     根据递归的定义，递归的解就是基于子问题的解构建的。通常只要在f(n-1) 的解中加入、移除某些东西或者稍作修改就能算出f(n) 。而在其他情况下，你可能要分别计算每部分的解，然后合并成最后结果。</p><p>将问题分解为子问题的方式多种多样。其中最常用的三种就是自底向上、自上而下和数据分割</p><p>​     9.8.1.1　自底向上的递归</p><p>​          自底向上的递归往往最为直观。我们从解决问题的简单情况开始，比如，列表中只有一个元素时。然后再解决有2个元素、3个元素的情况，以此类推。关键在于，如何基于 上一种情况的答案（或者前面所有情况）得出后一种情况的解。</p><p>​     9.8.1.2　自上而下的递归</p><p>​          遇到这类问题时，试着把变量为N 的情况分解成子问题的解。但要注意：分解的子问题间是否有重叠。</p><p>​          </p><p>​     9.8.1.3　数据分割的递归</p><p>​          归并排序也是一个“数据分割”的递归。我们排序数组的每一半，之后将其合并。</p><p>​          </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_197" target="_blank" rel="noopener">9.8.2　递归与迭代</a></p><p>​          递归算法极其耗空间。每次递归调用都会增加一层新的方法入栈，简而言之，如果递归深度为n ，那么最少占用O(n) 的空间。</p><p>​          鉴于此，用迭代实现递归算法往往更好。所有的 递归都可以用迭代实现，只不过有时会让代码超级复杂。所以有了递归算法之后，不要急于实现。先问问自己用迭代实现难不难，也可以和面试官讨论该如何权衡。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_198" target="_blank" rel="noopener">9.8.3　动态规划及记忆法</a></p><p>​     通常来说，动态规划就是使用递归算法发现重叠子问题（也就是重复的调用）。然后你可以缓存结果以备不时之需。</p><p>除此之外，你还可以研究递归调用的模式，实现其中重复的部分。这里仍然可以“缓存”中间结果。</p><p>​     画递归调用树可以很好地用来计算递归算法运行时间。</p><p>​     自上而下的动态规划（记忆法）</p><p>​     自底向上的动态规划</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_199" target="_blank" rel="noopener">9.9　系统设计与可扩展性</a></p><p>​     </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_200" target="_blank" rel="noopener">9.9.1　处理问题</a></p><p>​     在面试中，你作为求职者应该起到主导作用。当然，这不是让你忽略面试官，相反地，要与面试官保持沟通。然而，你应主导问题：提出问题，讨论利弊，深入沟通，做出优化。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_201" target="_blank" rel="noopener">9.9.2　循环渐进的设计</a></p><p>​          9.9.2.1　步骤1：审题</p><p>​          9.9.2.2　步骤2：作合理假设</p><p>​          9.9.2.3　步骤3：画出主要组件</p><p>​          9.9.2.4　步骤4：确定主要问题</p><p>​          9.9.2.5　步骤5：针对主要问题重新设计</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_202" target="_blank" rel="noopener">9.9.3　逐步构建的方法：循序渐进</a></p><p>​          9.9.3.1　步骤1：提出问题</p><p>​              </p><p>​          9.9.3.2　步骤2：大胆假设</p><p>​              </p><p>​          9.9.3.3　步骤3：切合实际</p><p>​              </p><p>​          9.9.3.4　步骤4：解决问题</p><p>​              </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_203" target="_blank" rel="noopener">9.9.4　关键概念</a></p><p>​          9.9.4.1　水平扩展与垂直扩展</p><p>​          9.9.4.2　负载均衡</p><p>​          9.9.4.3　数据库反规范化和非关系型数据库</p><p>​          9.9.4.4　数据库分区（分片）</p><p>​          9.9.4.5　缓存</p><p>​          9.9.4.6　异步处理与队列</p><p>​          9.9.4.7　网络指标</p><p>​          9.9.4.8　MapReduce</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_204" target="_blank" rel="noopener">9.9.5　系统设计要考虑的因素</a></p><p>​          故障</p><p>​          可用性与可靠性</p><p>​          读多写少与写多读少</p><p>​          安全性</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_205" target="_blank" rel="noopener">9.9.6　人无完人，系统亦然</a></p><p>​          鉴于此，你的目标应该是，理解用例，仔细审题，作出合理的假设，根据假设给出一个可靠的设计，然后阐明设计的利弊。不要心存幻想，一味追求完美的系统。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_206" target="_blank" rel="noopener">9.9.7　实例演示</a></p><p>​          给定数百万份文件，如何找出所有包含某一组词的文件？这些词出现的顺序不定，但必须是完整的单词，也就是说，book与bookkeeper不能混为一谈。</p><p>​          第一步是先忘记我们有数以百万计的文件，假装只有几十个文件。在这种情况下，如何实现findWords 呢？</p><p>现在，回到最初的问题。若有数百万份文件，会有什么问题？首先，我们可能需要将文件分散到多台机器上。此外，我们还要考虑很多因素，比如要查找的单词数量，在文件中重复出现的次数等，一台机器可能放不下完整的散列表。假设我们就要按这些限制因素进行设计。</p><p>文件分散到多台机器上会引出以下几个很关键的问题。</p><p>(1) 如何划分该散列表？我们可以按关键字划分，例如，某台机器上存放包含某个单词的全部文件，或者可以按文件来划分，这样一台机器上只会存放对应某个关键字的部分文件而非全部。</p><p>(2) 一旦决定了如何划分数据，我们可能需要在一台机器上对文件进行处理，并将结果推送到其他机器上。这个过程会是什么样呢？（注意：若按文件划分散列表，可能就不需要这一步。）</p><p>(3) 我们需要找到一种方法获知哪台机器拥有哪些数据。这个查找表会是什么样的？又该存储在什么地方？</p><p>这只是三个主要问题，可能还会有很多其他问题。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_207" target="_blank" rel="noopener">9.10　排序与查找</a></p><p>​          掌握常见的排序与查找算法大有裨益，因为很多排序与查找问题实际上只是将大家熟悉的算法稍作修改而已。因此，处理这类问题的诀窍在于，逐一考虑各种不同的排序算法，看看哪一种较为合适。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_208" target="_blank" rel="noopener">9.10.1　常见的排序算法</a></p><p>​          归并排序（merge sort）、快速排序（quick sort）和桶排序（bucket sort）是面试中最常用的3种类型</p><p>​          9.10.1.1　冒泡排序|执行时间：平均情况与最差情况为O(n^2)，存储空间：O(1)</p><p>​          9.10.1.2　选择排序|执行时间：平均情况与最差情况为O(n^2)，存储空间：O(1)</p><p>​          9.10.1.3　归并排序|执行时间：平均情况与最差情况为O(n\log(n)) ，存储空间：看情况</p><p>​          9.10.1.4　快速排序|执行时间：平均情况为O(n\log(n))，最差情况为O(n^2)，存储空间：O(\log(n))</p><p>​          9.10.1.5　基数排序|执行时间：O(kn)</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_209" target="_blank" rel="noopener">9.10.2　查找算法</a></p><p>​          除了二分查找，还有很多种查找数据结构的方法，总之，我们不要拘泥于二分查找。比如说，你可以利用二叉树或使用散列表来查找某节点。</p><p>​          </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_210" target="_blank" rel="noopener">9.11　 测试</a></p><p>测试问题一般分为以下4类：(1) 测试现实生活中的事物（比如一支笔）；(2) 测试一套软件；(3) 编写代码测试一个函数；(4) 调试解决已知问题。针对每一类题型，我们都会给出相应的解法。</p><p>请记住：处理这4类问题时，切勿假设使用者会做到运用自如，而是做好应对用户误用乱用软件的准备。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_211" target="_blank" rel="noopener">9.11.1　面试官想考查什么</a></p><p>​          表面上看，测试问题主要考查你能否想到周全完备的测试用例。除此之外，面试官还想考查以下几个方面。</p><p>​          全局观</p><p>​          懂整合</p><p>​          会组织 </p><p>​          可操作</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_212" target="_blank" rel="noopener">9.11.2　测试现实生活中的事物</a></p><p>​          使用者是哪些人？做什么用</p><p>​              考虑用户需求</p><p>​          有哪些用例</p><p>​              正常情况下的使用</p><p>​          有哪些使用限制</p><p>​              正常情况使用的限制</p><p>​          压力条件与失效条件是什么</p><p>​              非正常情况</p><p>​          如何执行测试</p><p>​              手动测试或自动化测试</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_213" target="_blank" rel="noopener">9.11.3　测试一套软件</a></p><p>​          测试软件与测试现实生活的事物大同小异。主要差别在于软件测试往往更强调执行测试的细节。</p><p>请注意，软件测试主要涉及如下两个方面。</p><p>​          手动测试与自动化测试</p><p>​          黑盒测试与白盒测试</p><p>9.11.3.1　步骤1：要做黑盒测试还是白盒测试</p><p>9.11.3.2　步骤2：使用者是哪些人？做什么用</p><p>9.11.3.3　步骤3：有哪些用例</p><p>9.11.3.4　步骤4：有哪些使用限制</p><p>9.11.3.5　步骤5：压力条件和失效条件为何</p><p>9.11.3.6　步骤6：有哪些测试用例？如何执行测试</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_214" target="_blank" rel="noopener">9.11.4　测试一个函数</a></p><p>9.11.4.1　步骤1：定义测试用例</p><p>9.11.4.2　步骤2：定义预期结果</p><p>9.11.4.3　步骤3：编写测试代码</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_215" target="_blank" rel="noopener">9.11.5　调试与故障排除</a></p><p>9.11.5.1　步骤1：理清状况</p><p>9.11.5.2　步骤2：分解问题</p><p>​          优秀的测试人员会逐一排查每个步骤，诊断定位问题所在。</p><p>9.11.5.3　步骤3：创建特定的、可控的测试</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_216" target="_blank" rel="noopener">9.12　C 和 C++</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_217" target="_blank" rel="noopener">9.12.1　类和继承</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_218" target="_blank" rel="noopener">9.12.2　构造函数和析构函数</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_219" target="_blank" rel="noopener">9.12.3　虚函数</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_220" target="_blank" rel="noopener">9.12.4　虚析构函数</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_221" target="_blank" rel="noopener">9.12.5　默认值</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_222" target="_blank" rel="noopener">9.12.6　操作符重载</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_223" target="_blank" rel="noopener">9.12.7　指针和引用</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_224" target="_blank" rel="noopener">9.12.8　模板</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_225" target="_blank" rel="noopener">9.13　Java</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_226" target="_blank" rel="noopener">9.13.1　如何处理</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_227" target="_blank" rel="noopener">9.13.2　重载与重写</a></p><p>​     重载（overloading）是指两种方法的名称相同，但参数类型或个数不同</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_228" target="_blank" rel="noopener">9.13.3　集合框架</a></p><p>​     Java的集合框架（collection framework）至关重要，本书许多章节都有所涉及。下面介绍几个最常用的。</p><p>​     ArrayList</p><p>​     Vector </p><p>​     LinkedList </p><p>​     HashMap </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_229" target="_blank" rel="noopener">9.14　数据库</a></p><p>​     </p><p>​     </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_230" target="_blank" rel="noopener">9.14.1　SQL语法及各类变体</a></p><p>​     显式连接（explicit join）和隐式连接（implicit join）的语法显示如下。这两条语句的作用一样，至于选用哪条全看个人喜好。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_231" target="_blank" rel="noopener">9.14.2　规范化数据库和反规范化数据库</a></p><p>​     规范化数据库的设计目标是将冗余降到最低，反规范化数据库则是为了优化读取时间。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_232" target="_blank" rel="noopener">9.14.3　SQL语句</a></p><p>​     </p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_233" target="_blank" rel="noopener">9.14.4　小型数据库设计</a></p><p>​     9.14.4.1　步骤1：处理不明确之处</p><p>9.14.4.2　步骤2：定义核心对象</p><p>9.14.4.3　步骤3：分析表之间的关系</p><p>9.14.4.4　步骤4：研究该有什么操作动作</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_234" target="_blank" rel="noopener">9.14.5　大型数据库设计</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_235" target="_blank" rel="noopener">9.15　线程与锁</a></p><p>​     不管是什么公司，面试官常常会考查你对线程特别是对死锁的了解程度。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_236" target="_blank" rel="noopener">9.15.1　Java线程</a></p><p>​          在Java中，实现线程有以下两种方式：</p><p>通过实现java.lang.Runnable 接口；</p><p>通过扩展java.lang.Thread 类</p><p>9.15.1.1　实现Runnable接口</p><p>9.15.1.2　扩展Thread 类</p><p>9.15.1.3　扩展Thread 类与实现Runnable 接口</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_237" target="_blank" rel="noopener">9.15.2　同步和锁</a></p><p>关键字synchronized 和lock 是实现代码同步的基础。</p><p>9.15.2.1　同步方法</p><p>9.15.2.2　同步块</p><p>9.15.2.3　锁</p><p>若要实现更细粒度的控制，可以使用锁（lock）。锁（或监视器）用于对共享资源的同步访问，方法是将锁与共享资源关联在一起。线程必须先取得与资源关联的锁，才能访问共享资源。在任意时间点，最多只有一个线程能拿到锁，因此，只有一个线程可以访问共享资源。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_238" target="_blank" rel="noopener">9.15.3　死锁及死锁的预防</a></p><p>​     死锁的出现必须同时满足以下4个条件。</p><p>(1) 互斥 ：某一时刻只有一个进程能访问某一资源。或者，更准确地说，对某一资源的访问有限制；若资源数量有限，也可能出现死锁。</p><p>(2) 持有并等待 ：已持有某一资源的进程不必释放当前拥有的资源，就能要求更多的资源。</p><p>(3) 没有抢占 ：一个进程不能强制另一个进程释放资源。</p><p>(4) 循环等待 ：两个或两个以上的进程形成循环链，每个进程都在等待循环链中另一进程持有的资源。</p><p>若要预防死锁，只需避免上述任一条件，但这很棘手，因为其中有些条件很难满足。比如，想要避免条件(1)就很困难，因为许多资源同一时刻只能被一个进程使用（如打印机）。大部分预防死锁的算法都把重心放在避免条件(4)（即循环等待）上。</p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_239" target="_blank" rel="noopener">9.16　中等难题</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_240" target="_blank" rel="noopener">9.17　高难度题</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_241" target="_blank" rel="noopener">第 10 章　题目解法</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_242" target="_blank" rel="noopener">10.1　数组与字符串</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_243" target="_blank" rel="noopener">10.2　链表</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_244" target="_blank" rel="noopener">10.3　栈与队列</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_245" target="_blank" rel="noopener">10.4　树与图</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_246" target="_blank" rel="noopener">10.5　位操作</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_247" target="_blank" rel="noopener">10.6　数学与逻辑题</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_248" target="_blank" rel="noopener">10.7　面向对象设计</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_249" target="_blank" rel="noopener">10.8　递归与动态规划</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_250" target="_blank" rel="noopener">10.9　系统设计与可扩展性</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_251" target="_blank" rel="noopener">10.10　排序与查找</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_252" target="_blank" rel="noopener">10.11　测试</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_253" target="_blank" rel="noopener">10.12　C和C++</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_254" target="_blank" rel="noopener">10.13　Java</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_255" target="_blank" rel="noopener">10.14　数据库</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_256" target="_blank" rel="noopener">10.15　线程与锁</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_257" target="_blank" rel="noopener">10.16　中等难题</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_258" target="_blank" rel="noopener">10.17　高难度题</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_259" target="_blank" rel="noopener">第 11 章　进阶话题</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_260" target="_blank" rel="noopener">11.1　实用数学</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_261" target="_blank" rel="noopener">11.1.1　整数1至N的和</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_262" target="_blank" rel="noopener">11.1.2　2的幂的和</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_263" target="_blank" rel="noopener">11.1.3　对数的底</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_264" target="_blank" rel="noopener">11.1.4　排列</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_265" target="_blank" rel="noopener">11.1.5　组合</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_266" target="_blank" rel="noopener">11.1.6　归纳证明</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_267" target="_blank" rel="noopener">11.2　拓扑排序</a></p><p><a href="http://reader.epubee.com/books/mobile/68/68aef87e268c839b310672e61583b9af/text00000.html#nav_point_268" target="_blank" rel="noopener">11.3　Dijkstra算法</a></p><p>​     </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/41682.html"/>
      <url>/41682.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>On Java 8</title>
      <link href="/29494.html"/>
      <url>/29494.html</url>
      
        <content type="html"><![CDATA[<h2 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h2><p>​        把万物看作对象，对象之间在传递信息。</p><p>​        对象的创建，对象的存储（数量、类型），对象之间的关系处理（对象间传递信息），对象的销毁，异常处理</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>​        Java 为单继承语言，有别于多继承的C++</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>​        多样式与向上转型</p><p>​        多态和构造器</p><p>​        <strong>多态的好处</strong>在于解耦</p><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>​        组合和继承</p><p>​        构造器加载顺序（对比销毁顺序）</p><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>​        接口为抽象类</p><p>​        接口被用来建立类之间的协议</p><p>​        接口中的守卫方法或虚拟扩展方法（default）</p><p>​        类可以实现多个接口，但是抽象类只能继承单一抽象类</p><p>​        面向接口编程，将接口与实现解耦可以应用于多种不同的实现</p><p>​        选择问题：</p><p>​                尽可能地抽象，更倾向使用接口而非抽象类</p><p>​        接口和策略模式</p><p>​        接口和工厂模式</p><p>​        优先使用类而不是接口，若有必要使用接口，再对代码重构也不迟。如果只是单纯为了设计接口而设计接口，只会徒增复杂性。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>​        内部自动类拥有对外部类所有成员的访问权，外部类与内部类产生的引用</p><p>​        匿名内部类，与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备，而如果是实现接口，也只能实现一个接口。</p><p>​        嵌套类</p><p>​        <strong>内部类有效地实现了多重继承</strong>，每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实习，对于内部类都没有影响</p><p>​        内部类的其他特性：</p><p>​                内部类可以有多个实例</p><p>​                再单个外部类中，可以让多个内部类以不同的方        式实现</p><p>​                创建内部类对象的时刻并不依赖于外部类对象的        创建</p><p>​                内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体    </p><p>​        内部类提供的闭包功能，相比指针更灵活更安全</p><p>​        回调的价值在于它的灵活性-可以再运行时动态地决定需要调用什么方法</p><p>​        在控制框架使用内部类的价值</p><p>​        局部内部类和匿名内部类</p><p>设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>​        <strong>持有对象</strong>的思想</p><p>​        泛型与类型安全的集合</p><p>​        散列码和hashCode()</p><p>​        List可以在创建后添加或删除元素，并自行调整大小</p><p>​        collection</p><p>​        迭代器，能够将遍历序列的操作与该序列的底层结构分离</p><p>​        for-in 和迭代器</p><p>​        集合和迭代器</p><p>​        <img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Ccollection.png" alt="collection"></p><p>​                                                                </p><p>​                上图中用粗黑的框包裹的类为常用的类</p><p><img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Ccollection1.png" alt="collection1"></p><p><img src="F:%5CBlog%5Csource_posts%5COn-Java-8%5Cmap.png" alt="map"></p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>​            lambda表达式</p><p>​            方法引用</p><p>​            函数式接口：</p><p>​                    在使用函数式接口时，名称无关紧要，只要参数类型和返回类型相同</p><p>​            高阶函数</p><p>​            闭包，利用闭包可以轻松生成函数。支持闭包也叫变量捕获。只要有内部类就会有闭包</p><p>​                    等同final效果</p><p>​            函数组合，多个还能输组合成新函数    </p><p>​            柯里化和部分求值</p><p>​                        柯里化，将一个多参数函数转换为一系列单参数函数</p><p>​            纯函数式编程，Scala，Clojure</p><h2 id="流式编程"><a href="#流式编程" class="headerlink" title="流式编程"></a>流式编程</h2><p>​            集合优化了对象的存储，而流和对象有关。流是一系列与特定存储机制无关的元素。利用流，可以不迭代集合中的元素，就可以提取和操作数据。<strong>流的好处是，它使得程序更加短小和容易理解</strong>。</p><p>​            Lambda表达式和方法引用结合流式编程会更加简便、简洁。</p><p>​            流式编程是一种声明式编程，声明要做什么，而非怎么做的编程风格。</p><p>​            流式编程采用内部迭代。</p><p>​            流是懒加载的。</p><p>​            流操作，创建流，修该流元素，消费流元素</p><p>​            创建流：</p><p>​                    stream.of(); stream(); 集合通过stream()方法来产生一个流。</p><p>​            中级流操作</p><p>​            optional类</p><p>​            终端操作</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>​            异常处理程序，不仅能节省代码，而且把“描述在正常执行剁成中做什么事”和“出了问题怎么办”的代码相分离。异常机制使代码的阅读、编写和调试工作更加井井有条。</p><p>​            基本异常</p><p>​            异常捕获</p><p>​            自定义异常</p><p>​            异常声明</p><p>​                    重新抛出异常</p><p>​                    异常链</p><p>​            Java标准异常</p><p>​            finally 用于把除内存之外的资源恢复到他们初始状态时。如果把finally子句和带标签的break及continue配合使用，在Java里就没必要使用goto语句了</p><p>​            异常丢失</p><p>​            异常限制</p><p>​            构造器和异常处理</p><p>​            Try-With-Resources和构造器异常处理</p><p>​            异常匹配</p><p>​            异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。异常处理的一个中哟啊目标就是把错误处理的代码同错误发生的地点相分离。</p><p>​            <strong>吞了异常</strong></p><p>​            被检查的异常与并发症</p><p>​                    所有模型都是错误的，但有些是            能用的。</p><p>​            反射和泛型就是用来补偿静态类型检查所带来的过多限制。</p><p>​            好的程序设计语言能帮助程序员写出好程序，但无论哪种语言都避免不了程序员用它写出坏程序。</p><p>​            把被检查的异常转换为不检查的异常</p><p>​                    异常链</p><p>​                    用RuntimeException来包装，被检查的异常</p><p>​            异常指南</p><p>​                    1.尽可能使用 try-with-resource。</p><p>​                    2.在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）</p><p>​                    3.解决问题并且重新调用产生异常的方法。</p><p>​                    4.进行少许修补，然后绕过异常发生的地方继续执行。</p><p>​                    5.用别的数据进行计算，以代替方法预计会返回的值。</p><p>​                    6.把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</p><p>​                    7.把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</p><p>​                    8.终止程序。</p><p>​                    9.进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。）</p><p>​                    10.让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）</p><p>​            报告功能是异常的精髓所在</p><h2 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h2><p>让代码健壮的方法    </p><p>​        测试</p><p>​                单元测试</p><p>​        前置条件（契约式设计DBC）</p><p>​                断言</p><p>​                Java断言语法</p><p>​                Guava断言</p><p>​                检查指令</p><p>​        测试驱动开发（TDD）</p><p>​        日志</p><p>​        调试</p><p>​                JDB、图形化调试器</p><p>​        基准测试</p><p>​        剖析和优化</p><p>​                剖析和优化</p><p>​                优化准则</p><p>​                        避免为了性能牺牲代码的可读性。</p><p>​                        不要独立地看待性能。衡量与带来的收益相                比所需投入的工作量。</p><p>​                        程序的大小很重要。性能优化通常只对运行                了长时间的大型项目有价值。性能通常不是小项                目的关注点。</p><p>​                        运行起来程序比一心钻研它的性能具有更高                的优先级。一旦你已经有了可工作的程序，如有                必要的话，你可以使用剖析器提高它的效率。只                有当性能是关键因素时，才需要在设计/开发阶段                考虑性能。</p><p>​                        不要猜测瓶颈发生在哪。运行剖析器，让剖                析器告诉你。</p><p>​                        无论何时有可能的话，显式地设置实例为                 null 表明你不再用它。这对垃圾收集器来说是个                有用的暗示。</p><p>​                        <strong>static final</strong> 修饰的变量会被 JVM 优化从而                提高程序的运行速度。因而程序中的常量应该声                明 <strong>static final</strong>。</p><p>​        风格检测</p><p>​        静态错误分析</p><p>​        代码重审</p><p>​        结对编程</p><p>​        重构：</p><p>​                重构基石：</p><p>​                        测试</p><p>​                        自动构建</p><p>​                        版本控制</p><p>​        持续集成</p><p>​                持续集成服务器</p><p>​                持续集成需要分布式版本管理，自动构建和自动        测测试系统作为基础</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>​        流与文件结合使得文件操作编程变得更加优雅</p><p>​        文件和目录路径</p><p>​                选取部分路径片段</p><p>​                路径分析</p><p>​                        FIile工具类</p><p>​        文件系统</p><p>​        路径监听</p><p>​                文件删除和线程</p><p>​        文件查找</p><p>​        文件读写</p><p>​        </p><p>​        java.nio.file        </p><p>​        java.nio.file.Files</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>​        字符串的不可变</p><p>​                参数是为该方法提供信息的，而不是想让该方法        改变自己的</p><p>​        +的重载与StringBuilder</p><p>​                不可变性与效率，string与stringbuilder类</p><p>​                在有循环且有性能问题时，使用stringbuilder类</p><p>​                stringbuffer与stringbuilder，stringbuffer是线        程安全的，因此开销会大一些。</p><p>​        意外递归</p><p>​                打印对象内存地址，使用super.tostring()，而不        去使用this, 使用this会发生自动类型转换、递归调用</p><p>​        字符串操作</p><p>​                当需要改变字符串的内容时，<code>String</code> 类的方法        都会返回一个新的 <code>String</code> 对象。同时，如果内容不        改变，<code>String</code> 方法只是返回原始对象的一个引用而        已。这可以节约存储空间以及避免额外的开销</p><p>​                在 Java 中，字符串操作还主要集中于<code>String</code>、        <code>StringBuffer</code> 和 <code>StringTokenizer</code> 类</p><p>​        格式化输出</p><p>​                printf()</p><p>​                System.out.format()</p><p>​                Formatter类，</p><p>​                        在 Java 中，所有的格式化功能都是由                <code>java.util.Formatter</code> 类处理的。</p><p>​        格式化修饰符</p><p>​                <code>Formatter</code> 转换</p><p>​                        还有许多不常用的类型转换与格式修饰符选                项，你可以在 JDK 文档中的 <code>Formatter</code> 类部分                找到它们。</p><p>​                String.format()</p><p>​                        在 <code>String.format()</code> 内部，它也是创建了                一个 <code>Formatter</code> 对象，然后将你传入的参数转                给 <code>Formatter</code>。不过，与其自己做这些事情，不                如使用便捷的 <code>String.format()</code> 方法，何况这                样的代码更清晰易读。</p><p>​        一个十六进制转储（dump）工具</p><p>​                为了打开及读入二进制文件，我们用到了另一个        工具 <code>Files.readAllBytes()</code>，这已经在 <a href="">Files章节</a>         介绍过了。这里的 <code>readAllBytes()</code> 方法将整个文件        以 <code>byte</code> 数组的形式返回</p><p>​        正则表达式</p><p>​                处理string的匹配、选择、编辑以及验证</p><p>​                <code>String.split()</code> 还有一个重载的版本，它允许        你限制字符串分割的次数</p><p>​        创建正则表达式</p><p>​                正则表达式的完整构造子列表，请参考JDK文档         <code>java.util.regex</code> 包中的 <code>Pattern</code>类</p><p>​                当你学会了使用字符类（character classes）之        后，正则表达式的威力才能真正显现出来</p><p>​        量词</p><p>​                量词描述了一个模式捕获输入文本的方式</p><p>​        CharSequence</p><p>​                接口 <code>CharSequence</code> 从 <code>CharBuffer</code>、                <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 类中抽象        出了字符序列的一般化定义</p><p>​        Pattern<code>和</code>Matcher</p><p>​                java.util.regext.Matcher</p><p>​        <code>find()</code></p><p>​                <code>Matcher.find()</code> 方法可用来在 <code>CharSequence</code>         中查找多个匹配</p><p>​        start()<code>和</code>end()</p><p>​        <code>Pattern</code> 标记</p><p>​        split()</p><p>​        替换操作</p><p>​        reset()</p><p>​        正则表达式与 Java I/O</p><p>​        扫描输入</p><p>​                <code>Scanner</code> 分隔符</p><p>​        StringTokenizer类</p><p>​                在 Java 引入正则表达式（J2SE1.4）和         <code>Scanner</code> 类（Java SE5）之前，分割字符        串的唯一方法是使用 <code>StringTokenizer</code> 来        分词。不过，现在有了正则表达式和             <code>Scanner</code>，我们可以使用更加简单、更加简洁        的方式来完成同样的工作了</p><p>​                基本上，我们可以放心地说，                <code>StringTokenizer</code> 已经可以废弃不用了。</p><h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p>​        java如何在运行时识别对象和类信息：</p><p>​                “传统的”RTTI（运行时类型信息）</p><p>​                            使用 RTTI，我们可以查询某个                 <code>Shape</code> 引用所指向对象的确切类型，                然后择或者剔除特例。</p><p>​                “反射”机制：允许我们在运行时发现和        使用类信息。</p><p>​        <code>Class</code> 对象</p><p>​                类加载器</p><p>​                原生类加载器与额外的类加载器</p><p>​                        <code>Class</code> 对象仅在需要的时候才会被                加载，<code>static</code> 初始化是在类加载时进                行的</p><p>​                        无论何时，只要你想在运行时使用                类型信息，就必须先得到那个 <code>Class</code> 对                象的引    用。<code>Class.forName()</code> 就是                实现这个功能的一个便捷途径，因为使                用该方法你不需要先持有这个类型 的对                象。但是，如果你已经拥有了目标类的                对象，那就可以通过调用 <code>getClass()</code>                 方法来获取 <code>Class</code> 引用了，这个方法来                自根类 <code>Object</code>，它将返回表示该对象                实际类型的 <code>Class</code> 对象的引用</p><p>​                        <code>Class</code> 对象的 <code>newInstance()</code> 方                法是实现“虚拟构造器”的一种途径，虚                拟构造器可以让你在不知道一个类的确                切类型的时候，创建这个类的对象</p><p>​        类字面常量</p><p>​                类字面常量用于生成类对象的引用</p><p>​                为了使用类而做的准备工作实际包含三        个步骤</p><p>​                加载：这是由类加载器执行的。该步骤        将查找字节码（通常在 classpath 所指定的        路径中查找，但这并非是必须的），并从这        些字节码中创建一个 <code>Class</code> 对象</p><p>​                链接：在链接阶段将验证类中的字节        码，为 <code>static</code> 字段分配存储空间，并且如        果需要的话，将解析这个类创建的对其他类        的所有引用。</p><p>​                初始化：如果该类具有超类，则先初始        化超类，执行 <code>static</code> 初始化器和 <code>static</code>         初始化块。</p><p>​                仅使用 <code>.class</code> 语法来获得对类对象的        引用不会引发初始化。但与此相反，使用         <code>Class.forName()</code> 来产生 <code>Class</code> 引用会        立即就进行初始化</p><p>​        泛化的 <code>Class</code> 引用</p><p>​                向 <code>Class</code> 引用添加泛型语法的原因只是        为了提供编译期类型检查</p><p>​        <code>cast()</code> 方法</p><p>​                 Java 中用于 <code>Class</code> 引用的转型语                     法</p><p>​        类型转换检测    </p><p>​                已知的 RTTI 类型</p><p>​                        传统的类型转换，如 “<code>(Shape)</code>”，                由 RTTI 确保转换的正确性，如果执行了                一个        错误的类型转换，就会抛出一                个 <code>ClassCastException</code> 异常。</p><p>​                        代表对象类型的 <code>Class</code> 对象. 通过                查询 <code>Class</code> 对象可以获取运行时所需的                信息.</p><p>​                RTTI 在 Java 中还有第三种形式，那就        是关键字 <code>instanceof</code></p><p>​                 使用类字面量</p><p>​                        使用类字面量重新实现                     <code>PetCreator</code> 类的话，其结果在                很多方面都会更清晰。</p><p>​                一个动态 <code>instanceof</code> 函数</p><p>​                        <code>Class.isInstance()</code> 方法提供                了一种动态测试对象类型的方法。</p><p>​                        <code>isInstance()</code> 方法消除了对                 <code>instanceof</code> 表达式的需要</p><p>​                递归计数</p><p>​                        可以使用                                         <code>Class.isAssignableFrom()</code> 而不是预加载 <code>Map</code> ，并创建一个不限于计数 <code>Pet</code> 的通用工具</p><p>​                注册工厂</p><p>​                        </p><p>​        类的等价比较</p><p>​                查询类型信息时，需要注意：            instanceof 的形式(即 <code>instanceof</code> 或     <code>isInstance()</code> ，这两者产生的结果相同) 和与 Class 对象直接比较这两者间存在重要区别</p><p>​                <code>instanceof</code> 说的是“你是这个类，还是从这个类派生的类？”。而如果使用 <code>==</code> 比较实际的<code>Class</code> 对象，则与继承无关 —— 它要么是确切的类型，要么不是。</p><p>​        反射：运行时类信息</p><p>​                如果你不知道对象的确切类型，RTTI 会告        诉你。但是，有一个限制：必须在编        译时        知道类型，才能使用 RTTI 检测它，并对信息做        一些有用的事情。换句话说，编译器必须知道你        使用的所有类</p><p>​                反射提供了检测可用方法并生成方法名称        的机制</p><p>​                在运行时发现类信息的另一个令人信服的        动机是提供跨网络在远程平台上创建和执行对象        的能力。这称为<em>远程方法调用</em>（RMI），它使         Java 程序的对象分布在许多机器上</p><p>​                重要的是要意识到反射没有什么魔力。当        你使用反射与未知类型的对象交互时，JVM 将查        看该对象，并看到它属于特定的类（就像普通的         RTTI）。在对其执行任何操作之前，必须加载         <code>Class</code> 对象。因此，该特定类型的 <code>.class</code>         文件必须在本地计算机上或通过网络对 JVM 仍        然可用。因此，RTTI 和反射的真正区别在于，        使用 RTTI 时，编译器在编译时会打开并检查         .class文件。换句话说，你可以用“正常”的方式        调用一个对象的所有方法。通过反射，.class文        件在编译时不可用；它由运行时环境        打开        并检查。</p><p>​        类方法提取器</p><p>​                反射是用来支持其他java特性的，如对象序        列化、动态提取有关类的信息</p><p>​                编程时，当你不记得某个类是否有特定的        方法，并且不想在 JDK 文档中搜索索引或类层        次结构时，或者如果你不知道该类是否可以对         <code>Color</code> 对象执行任何操作时，该工具能节省不        少时间</p><p>​        动态代理</p><p>​                当你希望将额外的操作与“真实对象”做分离        时，代理可能会有所帮助，尤        其是当你想要轻松        地启用额外的操作时，反之亦然（设计模式就是        封装        变更—所以你必须改变一些东西以证明模        式的合理性）。例如，如果你想跟踪        RealObject中方法的调用，或衡量此类调用的开销，该怎么        办？你不想这部分    代码耦合到你的程序中，而代理能使你可以很轻松地添加或删除它</p><p>​                Java 的<em>动态代理</em>更进一步，不仅动态创建代理对        象而且动态处理对代理方法的调用。在动态代理上进行        的所有调用都被重定向到单个<em>调用处理程序</em>，该处理程        序负责发现调用的内容并决定如何处理</p><p>​                可以通过调用静态方法Proxy.newProxyInstance()来创建动态代理，该方法需要一个类加载器（通常可以从已加载的对象中获取）</p><p>​                通常执行代理操作，然后使用 <code>Method.invoke()</code> 将请求转发给被代理对象，并携带必要的参数。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是，可以过滤某些方法调用，同时传递其他方法调用：</p><p>​        Optional类</p><p>​                如果你使用内置的 <code>null</code> 来表示没有对象，每次        使用引用的时候就必须测试一下引用是否为 <code>null</code>，这        显得有点枯燥，而且势必会产生相当乏味的代码。问题        在于 <code>null</code> 没什么自己的行为，只会在你想用它执行        任何操作的时候产生 <code>NullPointException</code>。        <code>java.util.Optional</code>（首次出现是在<a href="https://github.com/LingCoder/OnJava8/tree/5d7462a629a410cb29f98938387daa0d846d8e4b/docs/book/docs/book/13-Functional-Programming.md">函数式编程</a>这            章）为 <code>null</code> 值提供了一个轻量级代理，<code>Optional</code>         对象可以防止你的代码直接抛出NullPointException。</p><p>​        标记接口</p><p>​                有时候使用一个<strong>标记接口</strong>来表示空值会更方便。标记接口里边什么都没有，你只要把它的名字当做标签来用就可以。</p><p>​                假设存在许多不同类型的 <code>Robot</code>，我们想让每种 <code>Robot</code> 都创建一个 <code>Null</code> 对象来执行一些特殊的操作——在本例中，即提供 <code>Null</code> 对象所代表 <code>Robot</code> 的确切类型信息。这些信息是通过动态代理捕获的：</p><p>​                无论何时，如果你需要一个空 <code>Robot</code> 对象，只需要调用 <code>newNullRobot()</code>，并传递需要代理的 <code>Robot</code> 的类型。这个代理满足了 <code>Robot</code> 和 <code>Null</code> 接口的需要，并提供了它所代理的类型的确切名字。</p><p>​        Mock 对象和桩</p><p>​                <strong>Mock 对象</strong>和 <strong>桩（Stub）</strong>在逻辑上都是 <code>Optional</code> 的变体。他们都是最终程序中所使用的“实际”对象的代理。不过，Mock 对象和桩都是假扮成那些可以传递实际信息的实际对象，而不是像 <code>Optional</code> 那样把包含潜在 <code>null</code> 值的对象隐藏</p><p>​                Mock 对象和桩之间的的差别在于程度不同。Mock 对象往往是轻量级的，且用于自测试。通常，为了处理各种不同的测试场景，我们会创建出很多 Mock 对象。而桩只是返回桩数据，它通常是重量级的，并且经常在多个测试中被复用。桩可以根据它们被调用的方式，通过配置进行修改。因此，桩是一种复杂对象，它可以做很多事情。至于 Mock 对象，如果你要做很多事，通常会创建大量又小又简单的 Mock 对象。</p><p>​            接口和类型</p><p>​                    <code>interface</code> 关键字的一个重要目标就是允许程序员隔离组件，进而<strong>降低耦合度</strong>。使用接口可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并不是对解耦的一种无懈可击的保障</p><p>​                    通过使用反射，仍然可以调用所有方法，甚至是 <code>private</code> 方法！如果知道方法名，你就可以在其 <code>Method</code> 对象上调用 <code>setAccessible(true)</code>，就像在 <code>callHiddenMethod()</code> 中看到的那样。</p><p>​                    任何方式都没法阻止反射调用那些非公共访问权限的方法。对于字段来说也是这样，即便是 <code>private</code> 字段：</p><p>​                    程序员往往对编程语言提供的访问控制过于自信，甚至认为 Java 在安全性上比其它提供了（明显）更宽松的访问控制的语言要优越。然而，正如你所看到的，事实并不是这样。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​            普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。</p><p>​            多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类</p><p>​            泛型实现了<em>参数化类型</em>，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。</p><p>​            与 C++ 的比较</p><p>​                    Java 中的泛型需要与 C++ 进行对比</p><p>​                    只有知道了某个技术不能做什么，你才能更好地做到所能做的</p><p>​            简单泛型</p><p>​                    一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足</p><p>​                    与其使用 <code>Object</code> ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用<em>类型参数</em>，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数</p><p>​                     Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。</p><p>​            一个元组类库</p><p>​                    有时一个方法需要能返回多个对象。而 <strong>return</strong> 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象</p><p>​                    这个概念称为<em>元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象</em> 或 <em>信使</em> ）。</p><p>​            一个堆栈类</p><p>​                    我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。</p><p>​                    内部类 <code>Node</code> 也是一个泛型，它拥有自己的类型参数</p><p>​            </p><p>​            RandomList</p><p>​                    作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 <code>select()</code> 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型</p><p>​            泛型接口</p><p>​                    泛型也可以应用于接口。例如 <em>生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法</em> 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象</p><p>​            泛型方法</p><p>​                    到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系</p><p>​                    泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂</p><p>​                    要定义泛型方法，请将泛型参数列表放置在返回值之前</p><p>​            变长参数和泛型方法</p><p>​                    泛型方法和变长参数列表可以很好地共存</p><p>​            一个泛型的 Supplier</p><p>​                    这是一个为任意具有无参构造方法的类生成 <strong>Supplier</strong> 的类。为了减少键入，它还包括一个用于生成 <strong>BasicSupplier</strong> 的泛型方法</p><p>​            简化元组的使用</p><p>​                    使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库</p><p>​            一个 Set 工具</p><p>​                    对于泛型方法的另一个示例，请考虑由 <strong>Set</strong> 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：</p><p>​            构建复杂模型</p><p>​                    泛型的一个重要好处是能够简单安全地创建复杂模型</p><p>​            泛型擦除</p><p>​                    Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时实际上是相同的类型。它们都被擦除成原生类型 <code>List</code></p><p>​                    理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一</p><p>​                    为了调用 <code>f()</code>，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 <strong>extends</strong> 关键字。由于有了边界，下面的代码就能通过编译：</p><p>​                    泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 <code>&lt;T extends HasF&gt;</code> 形式就是有缺陷的。例如，如果某个类有一个返回 <strong>T</strong> 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型</p><p>​                    你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。</p><p>​            迁移兼容性</p><p>​                    为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样</p><p>​                    擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。</p><p>​                    擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。</p><p>​                    因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。    </p><p>​                    擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。</p><p>​                    类库毫无争议是编程语言的一部分，对生产效率有着极大的影响</p><p>​            </p><p>​            擦除的问题</p><p>​                    因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。</p><p>​                    擦除和迁移兼容性意味着，使用泛型并不是强制的，</p><p>​            边界处的动作</p><p>​                    因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物</p><p>​                    对于在泛型中创建数组，使用 <code>Array.newInstance()</code> 是推荐的方式</p><p>​                    即使编译器无法得知 <code>add()</code> 中的 <strong>T</strong> 的任何信息，但它仍可以在编译期确保你放入 <strong>FilledList</strong> 中的对象是 <strong>T</strong> 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。</p><p>​                    泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型</p><p>​            补偿擦除</p><p>​                    因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型</p><p>​                    有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它</p><p>​            创建类型的实例</p><p>​                    试图在 <strong>Erased.java</strong> 中 <code>new T()</code> 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 <strong>T</strong> 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）</p><p>​            泛型数组</p><p>​                    正如在 <strong>Erased.java</strong> 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 <strong>ArrayList</strong></p><p>​                    成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换</p><p>​                    由于擦除，数组的运行时类型只能是 <code>Object[]</code> 。 如果我们立即将其转换为 <code>T[]</code> ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 <code>Object[]</code> ，并在使用数组元素时向 <strong>T</strong> 添加强制类型转换</p><p>​            边界</p><p>​                    <em>边界</em>（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法</p><p>​            通配符</p><p>​                    真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。</p><p>​                    但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。</p><p>​            编译器有多聪明</p><p>​                    如果创建了一个 <code>Holder&lt;Apple&gt;</code>，就不能将其向上转型为 <code>Holder&lt;Fruit&gt;</code>，但是可以向上转型为 <code>Holder&lt;? extends Fruit&gt;</code></p><p>​            逆变？</p><p>​                    还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;？super MyClass&gt;</code> ，或者甚至使用类型参数： <code>&lt;？super T&gt;</code>（尽管你不能对泛型参数给出一个超类型边界；即不能声明 <code>&lt;T super MyClass&gt;</code> ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 <strong>Collection</strong> 写入了</p><p>​            无界通配符</p><p>​                    无界通配符 <code>&lt;?&gt;</code> 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的</p><p>​                    <strong>List</strong> 实际上表示“持有任何 <strong>Object</strong> 类型的原生 <strong>List</strong> ”，而 <code>List&lt;?&gt;</code> 表示“具有某种特定类型的非原生 <strong>List</strong> ，只是我们不知道类型是什么。</p><p>​                    因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。</p><p>​            捕获转换</p><p>​                    有一种特殊情况需要使用 <code>&lt;?&gt;</code> 而不是原生类型。如果向一个使用 <code>&lt;?&gt;</code> 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。</p><p>​                    捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 <code>f2()</code> 中返回 <strong>T</strong>，因为 <strong>T</strong> 对于 <code>f2()</code> 来说是未知的。捕获转换十分有趣，但是非常受限。</p><p>​            问题</p><p>​                    任何基本类型都不能作为类型参数。</p><p>​                            解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 <code>ArrayList&lt;Integer&gt;</code>，并将基本类型 <strong>int</strong> 应用于这个集合，那么你将发现自动装箱机制将自动地实现 <strong>int</strong> 到 <strong>Integer</strong> 的双向转换——因此，这几乎就像是有一个 <code>ArrayList&lt;int&gt;</code> 一样</p><p>​                            自动装箱机制解决了一些问题，但并没有解决所有问题。</p><p>​                            自动装箱不适用于数组，因此我们必须创建 <code>FillArray.fill()</code> 的重载版本，或创建产生 <strong>Wrapped</strong> 输出的生成器。 <strong>FillArray</strong> 仅比 <code>java.util.Arrays.setAll()</code> 有用一点，因为它返回填充的数组</p><p>​                    实现参数化接口</p><p>​                            个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口</p><p>​                    转型和警告</p><p>​                            使用带有泛型类型参数的转型或 <strong>instanceof</strong> 不会有任何效果</p><p>​                            通过泛型类来转型？</p><p>​                    重载</p><p>​                            当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名</p><p>​                    基类劫持接口</p><p>​                            一旦 <strong>Comparable</strong> 的类型参数设置为 <strong>ComparablePet</strong>，其他的实现类只能比较 <strong>ComparablePet</strong>：</p><p>​                    自限定的类型</p><p>​                            这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong> 类接受泛型参数 <strong>T</strong>，而 <strong>T</strong> 由一个边界类限定，这个边界就是拥有 <strong>T</strong> 作为其参数的 <strong>SelfBounded</strong></p><p>​                    古怪的循环泛型</p><p>​                            这可以按照 Jim Coplien 在 C++ 中的<em>古怪的循环模版模式</em>的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。 为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 <strong>Object</strong> 的类型</p><p>​                            注意，这里有些东西很重要：新类 <strong>Subtype</strong> 接受的参数和返回的值具有 <strong>Subtype</strong> 类型而不仅仅是基类 <strong>BasicHolder</strong> 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在<strong>Subtype</strong> 中，传递给 <code>set()</code> 的参数和从 <code>get()</code> 返回的类型都是确切的 <strong>Subtype</strong>。</p><p>​                    自限定    ？</p><p>​                            自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 <strong>SelfBounded</strong> 参数的 <strong>SelfBounded</strong> 中导出，尽管在 <strong>A</strong> 类看到的用法看起来是主要的用法。对定义 <strong>E</strong> 的尝试说明不能使用不是 <strong>SelfBounded</strong> 的类型参数。 遗憾的是， <strong>F</strong> 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。 注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 <strong>E</strong> 也会因此而变得可编译</p><p>​                            因此很明显，自限定限制只能强制作用于继承关系</p><p>​                    参数协变 ？</p><p>​                            自限定类型的价值在于它们可以产生<em>协变参数类型</em>——方法参数类型会随子类而变化。</p><p>​                            自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 <code>get()</code> 中所看到的一样</p><p>​                            <code>set(derived)</code> 和 <code>set(base)</code> 都是合法的，因此 <code>DerivedSetter.set()</code> 没有覆盖 <code>OrdinarySetter.set()</code> ，而是重载了这个方法。从输出中可以看到，在 <strong>DerivedSetter</strong> 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。 但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：</p><p>​                    动态类型安全</p><p>​                            因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 <strong>java.util.Collections</strong> 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 <code>checkedCollection()</code> 、<code>checkedList()</code>、 <code>checkedMap()</code> 、 <code>checkedSet()</code> 、<code>checkedSortedMap()</code>和 <code>checkedSortedSet()</code>。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</p><p>​                    泛型异常</p><p>​                            由于擦除的原因，<strong>catch</strong> 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 <strong>Throwable</strong>（这将进一步阻止你去定义不能捕获的泛型异常）。但是，类型参数可能会在一个方法的 <strong>throws</strong> 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码</p><p>​                    混型？</p><p>​                            术语<em>混型<em>随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。 混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点</em>面向切面编程</em> （AOP） 的味道，而切面经常被建议用来解决混型问题</p><p>​                    C++ 中的混型？</p><p>​                            泛型类不能直接继承自一个泛型参数</p><p>​                    与接口混合？</p><p>​                            一种更常见的推荐解决方案是使用接口来产生混型效果</p><p>​                    使用装饰器模式？</p><p>​                             装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。</p><p>​                            也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案</p><p>​                    与动态代理混合</p><p>​                            可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/19-Type-Information.md">类型信息</a> 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。 由于动态代理的限制，每个被混入的类都必须是某个接口的实现</p><p>​                            因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。</p><p>​                    潜在类型机制</p><p>​                            在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。</p><p>​                            泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 <code>speak()</code> 和 <code>sit()</code> 即可。”由于不要求具体类型，因此代码就可以更加泛化。</p><p>​                            潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方</p><p>​                            支持潜在类型机制的语言包括 Python（可以从 <a href="http://www.Python.org" target="_blank" rel="noopener">www.Python.org</a> 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查</p><p>​                    pyhton 中的潜在类型</p><p>​                            <code>perform()</code> 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持 <code>speak()</code> 和 <code>sit()</code> 方法。如果传递给 <code>perform()</code> 的对象不支持这些操作，那么将会得到运行时异常。</p><p>​                    C++ 中的潜在类型</p><p>​                            在 Python 和 C++ 中，<strong>Dog</strong> 和 <strong>Robot</strong> 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，<code>perform()</code> 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。 C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。潜在类型机制没有损害强类型机制。</p><p>​                    Go 中的潜在类型</p><p>​                            <code>main()</code> 证明 <code>perform()</code> 确实对其参数的确切类型不在乎，只要可以在该参数上调用 <code>talk()</code> 和 <code>sit()</code> 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。</p><p>​                    java中的直接潜在类型</p><p>​                            因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8 之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它</p><p>​                    对缺乏潜在类型机制的补偿</p><p>​                            尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。</p><p>​                            反射    </p><p>​                                    这些类完全是彼此分离的，没有任何公共基类（除了 <strong>Object</strong> ）或接口。通过反射, <code>CommunicateReflectively.perform()</code> 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 <strong>Mime</strong> 只具有一个必需的方法这一事实，并能够部分实现其目标。</p><p>​                            将一个方法应用于序列    </p><p>​                                    反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？    </p><p>​                    Java8 中的辅助潜在类型</p><p>​                            尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 <code>CommunicateA.perform()</code> ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。</p><p>​                    使用<strong>Suppliers</strong>类的通用方法</p><p>​                            通过辅助潜在类型，我们可以定义本章其他部分中使用的 <strong>Suppliers</strong> 类。 此类包含使用生成器填充 <strong>Collection</strong> 的工具方法。 泛化这些操作很有意义：</p><p>​                    总结：类型转换真的如此之糟吗？</p><p>​                            使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 <strong>List</strong> 、各种 <strong>Set</strong> 、各种 <strong>Map</strong> 等你在 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/12-Collections.md">集合</a> 和 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/Appendix-Collection-Topics.md">附录：集合主题</a> 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 <strong>Object</strong> ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 <strong>Cat</strong> 的 <strong>List</strong> （这个示例的一种使用苹果和桔子的变体在 <a href="https://github.com/LingCoder/OnJava8/tree/c9abc5c07ef502f6b0b83926993918a15febd576/docs/book/book/12-Collections.md">集合</a> 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 <strong>Object</strong> 。因此，我们很可能会将一个 <strong>Dog</strong> 放置到 <strong>Cat</strong> 的 <strong>List</strong> 中</p><p>​                            但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 <strong>Dog</strong> 扔到 <strong>Cat</strong> 的集合中，并且试图将这个集合中的所有东西都当作 <strong>Cat</strong> 处理，那么当你从这个 <strong>Cat</strong> 集合中取回那个 <strong>Dog</strong> 引用，并试图将其转型为 <strong>Cat</strong> 时，就会得到一个 <strong>RuntimeException</strong> 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的</p><p>​                            泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。</p><p>​                            正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​            随着 Java Collection 和 Stream 类中高级功能的不断增加，日常编程中使用数组的需求也在变少，所以你暂且可以放心地略读甚至跳过这一章。但是，即使你自己避免使用数组，也总会有需要阅读别人数组代码的那一天。</p><p>​            数组特性</p><p>​                    将数组和其他类型的集合区分开来的原因有三：效率，类型，保存基本数据类型的能力。在 Java 中，使用数组存储和随机访问对象引用序列是非常高效的。数组是简单的线性序列，这使得对元素的访问变得非常快。然而这种高速也是有代价的，代价就是数组对象的大小是固定的，且在该数组的生存期内不能更改。</p><p>​                    不管在编译时还是运行时，Java都会阻止你犯向对象发送不正确消息的错误。然而不管怎样，使用数组都不会有更大的风险。比较好的地方在于，如果编译器报错，最终的用户更容易理解抛出异常的含义。</p><p>​                    一个数组可以保存基本数据类型，而一个预泛型的集合不可以。然而对于泛型而言，集合可以指定和检查他们保存对象的类型，而通过 <strong>自动装箱</strong> (autoboxing)机制，集合表现地就像它们可以保存基本数据类型一样，因为这种转换是自动的。</p><p>​                    数组和 <strong>ArrayList</strong> 之间的相似是设计者有意为之，所以在概念上，两者很容易切换。但是就像你在<a href="https://github.com/LingCoder/OnJava8/tree/3c08903cf0e58229fe8ae1360869bc55d6dd7024/docs/book/book/12-Collections.md">集合</a>中看到的，集合的功能明显多于数组。随着 Java 自动装箱技术的出现，通过集合使用基本数据类型几乎和通过数组一样简单。数组唯一剩下的优势就是效率。然而，当你解决一个更加普遍的问题时，数组可能限制太多，这种情形下，您可以使用集合类。</p><p>​            用于显示数组的实用程序</p><p>​            一等对象</p><p>​                    不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语法的一部分，也可以显式地创建，比如使用一个 <strong>new</strong> 表达式。数组对象的一部分（事实上，你唯一可以使用的方法）就是只读的 <strong>length</strong> 成员函数，它能告诉你数组对象中可以存储多少元素。<strong>[ ]</strong> 语法是你访问数组对象的唯一方式。</p><p>​            返回数组</p><p>​                    假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。对 C++/C 这样的语言来说这是很困难的，因为你无法返回一个数组，只能是返回一个指向数组的指针。这会带来一些问题，因为对数组生存期的控制变得很混乱，这会导致内存泄露。</p><p>​            多维数组</p><p>​                    非基元的对象数组也可以定义为不规则数组</p><p>​                    数组初始化时使用自动装箱技术</p><p>​            泛型数组</p><p>​                    一般来说，数组和泛型并不能很好的结合。你不能实例化参数化类型的数组，类型擦除需要删除参数类型信息，而且数组必须知道它们所保存的确切类型，以强制保证类型安全。但是，可以参数化数组本身的类型。</p><p>​                    如果你知道你不会进行向上类型转换，你的需求相对简单，那么可以创建一个泛型数组，它将提供基本的编译时类型检查。然而，一个泛型 <strong>Collection</strong> 实际上是一个比泛型数组更好的选择。</p><p>​                    一般来说，您会发现泛型在类或方法的边界上是有效的。在内部，擦除常常会使泛型不可使用。</p><p>​            Arrays的fill方法</p><p>​                    </p><p>​            Arrays的setAll方法</p><p>​            增量生成</p><p>​                    </p><p>​            随机生成</p><p>​                    </p><p>​            泛型和基本数组</p><p>​                    在本章的前面，我们被提醒，泛型不能和基元一起工作。在这种情况下，我们必须从基元数组转换为包装类型的数组，并且还必须从另一个方向转换。下面是一个转换器可以同时对所有类型的数据执行操作</p><p>​            数组元素修改</p><p>​                    </p><p>​            数组并行</p><p>​                    用简单的方法编写代码。不要开始处理并行性，除非它成为一个问题。您仍然会遇到并行性。在本章中，我们将介绍一些为并行执行而编写的Java库方法。因此，您必须对它有足够的了解，以便进行基本的讨论，并避免出现错误。</p><p>​            parallelSetAll()</p><p>​                    流式编程产生优雅的代码</p><p>​            Arrays工具类</p><p>​                    您已经看到了 <strong>java.util.Arrays</strong> 中的 <strong>fill()</strong> 和 <strong>setAll()/parallelSetAll()</strong> 。该类包含许多其他有用的 <strong>静态</strong> 程序方法，我们将对此进行研究</p><p>​            数组拷贝</p><p>​                    与使用for循环手工执行复制相比，<strong>copyOf()</strong> 和 <strong>copyOfRange()</strong> 复制数组要快得多。这些方法被重载以处理所有类型</p><p>​            数组比较</p><p>​                    数组相等的含义：数组必须有相同数量的元素，并且每个元素必须与另一个数组中的对应元素相等，对每个元素使用 <strong>equals()</strong>(对于原生类型，使用原生类型的包装类的 <strong>equals()</strong> 方法;例如，int的Integer.equals()。</p><p>​            流和数组</p><p>​                    <strong>stream()</strong> 方法很容易从某些类型的数组中生成元素流。</p><p>​                    通常，将数组转换为流来生成所需的结果要比直接操作数组容易得多。请注意，即使流已经“用完”(您不能重复使用它)，您仍然拥有该数组，因此您可以以其他方式使用它—-包括生成另一个流。</p><p>​            数组排序</p><p>​                    编程设计的一个主要目标是“将易变的元素与稳定的元素分开”，在这里，保持不变的代码是一般的排序算法，但是变化的是对象的比较方式。因此，使用策略设计模式而不是将比较代码放入许多不同的排序源码中。使用策略模式时，变化的代码部分被封装在一个单独的类(策略对象)中。</p><p>​                    Java有两种方式提供比较功能。第一种方法是通过实现 <strong>java.lang.Comparable</strong> 接口的原生方法。这是一个简单的接口，只含有一个方法 <strong>compareTo()</strong>。该方法接受另一个与参数类型相同的对象作为参数，如果当前对象小于参数，则产生一个负值;如果参数相等，则产生零值;如果当前对象大于参数，则产生一个正值。</p><p>​            Arrays.sort()的使用</p><p>​                    Java标准库中使用的排序算法被设计为最适合您正在排序的类型—-原生类型的快速排序和对象的归并排序。</p><p>​            并行排序</p><p>​                    如果排序性能是一个问题，那么可以使用 <strong>Java 8 parallelSort()</strong>，它为所有不可预见的情况(包括数组的排序区域或使用了比较器)提供了重载版本</p><p>​            binarySearch二分查找</p><p>​                    如果找到了搜索项，<strong>Arrays.binarySearch()</strong> 将生成一个大于或等于零的值。否则，它将产生一个负值，表示如果手动维护已排序的数组，则应该插入元素的位置。产生的值是 -(插入点) - 1 。插入点是大于键的第一个元素的索引，如果数组中的所有元素都小于指定的键，则是 <strong>a.size()</strong> 。</p><p>​            parallelPrefix并行前缀</p><p>​                    如前所述，使用流进行初始化非常优雅，但是对于大型数组，这种方法可能会耗尽堆空间。使用 <strong>setAll()</strong> 执行初始化更节省内存:</p><p>​                    因为正确使用 <strong>parallelPrefix()</strong> 可能相当复杂，所以通常应该只在存在内存或速度问题(或两者都有)时使用。否则，<strong>Stream.reduce()</strong> 应该是您的首选。</p><p>​            在经历了这么多年的Java发展之后，我们可以很有趣地推测，如果重新开始，设计人员是否会将原生类型和低级数组放在该语言中(同样在JVM上运行的Scala语言不包括这些)。如果不考虑这些，就有可能开发出一种真正纯粹的面向对象语言(尽管有这样的说法，Java并不是一种纯粹的面向对象语言，这正是因为它的底层缺陷)。关于效率的最初争论总是令人信服的，但是随着时间的推移，我们已经看到了从这个想法向更高层次的组件(如集合)的演进。此外，如果集合可以像在某些语言中一样构建到核心语言中，那么编译器就有更好的机会进行优化。</p><p>​                    </p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>​            </p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​            </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​            类层次结构</p><p>​            除了内存清理之外，所有的清理都不会自动发生</p><p>​        </p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构</title>
      <link href="/51507.html"/>
      <url>/51507.html</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>​        问题类型：</p><p>​                修改栈</p><p>​                递归与栈</p><p>​                树</p><p>​                利用栈实现队列</p><p>​        解法类型：</p><p>​                单调栈</p><p>​                双指针</p><p>​                双栈</p><p>​                观察并推导出数学公式</p><p>​                语言自带工具类</p><p>​            </p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>​                滑动窗口</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>​            注意：Deque同时具有双端队列的性质</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​            优先队列和堆</p><h2 id="优化算法的方法"><a href="#优化算法的方法" class="headerlink" title="优化算法的方法"></a>优化算法的方法</h2><p>​            二分法？？</p><p>​            </p><p>​                </p><p>​         </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>壁纸-无水印</title>
      <link href="/51748.html"/>
      <url>/51748.html</url>
      
        <content type="html"><![CDATA[<h2 id="从网站获取"><a href="#从网站获取" class="headerlink" title="从网站获取"></a>从网站获取</h2><p><a href="https://bing.ioliu.cn/" target="_blank" rel="noopener">历史必应</a></p><p><a href="http://lab.mkblog.cn/wallpaper/" target="_blank" rel="noopener">mkblog</a></p><p><a href="https://github.com/GallonHu/pic">github_GallonHu</a></p><h2 id="手动获取"><a href="#手动获取" class="headerlink" title="手动获取"></a>手动获取</h2><p>（1）打开必应官方网站</p><p>（2）鼠标右击图片，选择检查选项</p><p>（3） 找到Sources选项</p><p>（4）点击top栏目里最下方选项就能看到图片</p><p>（5）鼠标右击图片，选择保存</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo文章插图显示问题-个人测试有效</title>
      <link href="/7663.html"/>
      <url>/7663.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法一-GitHub路径"><a href="#方法一-GitHub路径" class="headerlink" title="方法一 GitHub路径"></a>方法一 GitHub路径</h2><p>​    （1）在Hexo下的.config.yml中设置post_asset_folder选项为true</p><p>​    （2）在git bash命令窗口下 使用hexo n “你的待插入图片的新建文章名称” 来生成新的md文件，在这个新建文件的同级目录下，会产生同名的文件夹。</p><p>​    （3）需要在新建md文件插入图片时，先把图片复制到（2）中的同名文件夹中</p><p>​    （4）按照花括号中的格式来插入图片<code>！[图片描述](待插入图片github中的路径)</code>。若没有路径，可先在git bash 上使用hexo相关命令提交文章来产生。例如，我上传文章的图片的路径为{<code>！[JVM 虚拟机运行时数据区](/17374/JVM.png)</code>}，如下图：</p><p>​                        <img src="/7663/github_path.png" alt="图片在github中的路径"></p><p>​                        <img src="/7663/Hexo_pic.png" alt="图片的在代码中显示的路径"></p><p>​     实际上，图片通过这种方法能正常显示是因为，图片通过这种上传方式已经存在于github上，再通过这种引用图片的格式<code>！[图片描述](待插入图片github中的路径)</code>，来显示图片。</p><h2 id="方法二-图床"><a href="#方法二-图床" class="headerlink" title="方法二 图床"></a>方法二 图床</h2><p>​        使用图床获取url链接来显示图片</p><p>​        参考方法：<a href="https://www.dazhuanlan.com/2019/09/26/5d8cbd5d55654/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/09/26/5d8cbd5d55654/</a></p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/17374.html"/>
      <url>/17374.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解JAVA虚拟机-第三版"><a href="#深入理解JAVA虚拟机-第三版" class="headerlink" title="深入理解JAVA虚拟机 (第三版)"></a>深入理解JAVA虚拟机 (第三版)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/17374/JVM.png" alt="JVM 虚拟机运行时数据区"></p><p>《深入理解JAVA虚拟》第三版主要围绕着上图来叙述，分为五大部分：</p><p>​        （1）JAVA发展历史：涉及JVM自诞生的版本到目前的版本的发展历程，其中，有讲述为何虚拟机会发生这样的演变，以及与其他类型虚拟机的的关系，并对虚拟机进行了展望。</p><p>​        （2）自动内存管理（运行时数据区）：涉及内存管理的异常，像内存溢出异常、OutOfMemory Error等，垃圾收集器，内存分配策略，故障处理方法与工具，调优方法。</p><p>​           (3）JVM执行子系统（执行）：类文件结构；JVM类加载的机制；字节码执行引擎；</p><p>​        （4）代码编译和优化；前端编译和优化（JAVA语法糖等）；后端编译与优化（即时编译、编译器优化技术-<strong>方法内联、逃逸分析</strong>等）</p><p>​        （5）高效并发：如何实现并发（JAVA内存模型）；如何高效实现并发（锁的介绍、<strong>锁优化</strong>-锁粗化、锁自旋、锁偏向等等）</p><p>若需要《深入理解JAVA虚拟机》第三版pdf，可发邮件至###qhuang724@gmail.com###（发送时去掉#）</p><p>​            </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transfer Learning</title>
      <link href="/8787.html"/>
      <url>/8787.html</url>
      
        <content type="html"><![CDATA[<h1 id="跨领域情感分析"><a href="#跨领域情感分析" class="headerlink" title="跨领域情感分析"></a>跨领域情感分析</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><pre><code>近几年的综述</code></pre><h2 id="相关研究者"><a href="#相关研究者" class="headerlink" title="相关研究者"></a>相关研究者</h2><h3 id="国内研究者"><a href="#国内研究者" class="headerlink" title="国内研究者"></a>国内研究者</h3><p><a href="https://www.zhihu.com/people/jindongwang/activities" target="_blank" rel="noopener">迁移学习手册——王晋东</a></p><h3 id="国外研究者"><a href="#国外研究者" class="headerlink" title="国外研究者"></a>国外研究者</h3>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugs</title>
      <link href="/30574.html"/>
      <url>/30574.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://chrischen0405.github.io/2018/11/21/post20181121-2/" target="_blank" rel="noopener">hexo发布文章报错can not read a block mapping entry</a></p><h1 id="bert"><a href="#bert" class="headerlink" title="bert"></a>bert</h1><p><a href="https://blog.csdn.net/yangdan1025/article/details/103293891" target="_blank" rel="noopener">Bert在Win10启动server TypeError: cannot unpack non-iterable NoneType object</a></p>]]></content>
      
      
      <categories>
          
          <category> Bugs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>algorithm per day</title>
      <link href="/29461.html"/>
      <url>/29461.html</url>
      
        <content type="html"><![CDATA[<h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><h3 id="two-sum"><a href="#two-sum" class="headerlink" title="two-sum"></a>two-sum</h3><pre><code>暴力解法：时间复杂度为O（n^2）运用HashMap：时间复杂度为O（1），相比较于暴力解法，在数据规模较大的时候，还是有时间上的优势的。关于containsKey()方法，根据某种哈希算法，直接定位所要的元素，也就是说，这个查找的方法的时间复杂度最好为O（1），若没有直接找到，存储方式变为红黑树，查询复杂度为O（lgn），而并非O（n^2）。</code></pre><p>参考：<a href="https://blog.csdn.net/qingtian_1993/article/details/80763381" target="_blank" rel="noopener">containsKey()方法的复杂度为何为O（1）</a></p><h3 id="mini-parser"><a href="#mini-parser" class="headerlink" title="mini-parser"></a>mini-parser</h3><pre><code>相似题目 flatten-nested-list-iterator</code></pre><h2 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h2><h3 id="next-greater-element-ii"><a href="#next-greater-element-ii" class="headerlink" title="next-greater-element-ii"></a>next-greater-element-ii</h3><pre><code>    暴力解法；    运用栈；        在解决循环列表的时候，可以用循环链表、列表中每个数重复两次（可能会有取余操作）、可以用三个for循环（暴力解法）。        题目中使用栈作为相邻有先后顺寻的元素的存储介质，利用栈的特性，方便得到结果，时间复杂度为O(1),空间复杂度为O（1）。</code></pre><h3 id="biao-qian-yan-zheng-qi-by-leetcode"><a href="#biao-qian-yan-zheng-qi-by-leetcode" class="headerlink" title="biao-qian-yan-zheng-qi-by-leetcode"></a>biao-qian-yan-zheng-qi-by-leetcode</h3><pre><code>    这个题目先放放。</code></pre><h3 id="exclusive-time-of-functions"><a href="#exclusive-time-of-functions" class="headerlink" title="exclusive-time-of-functions"></a>exclusive-time-of-functions</h3><pre><code>    利用栈来做，类似于中缀表达式求值</code></pre><h3 id="baseball-game"><a href="#baseball-game" class="headerlink" title="baseball-game"></a>baseball-game</h3><pre><code>    利用栈的先进后出的特点来操作数据，类似于中缀表达式求值</code></pre><h2 id="day-3"><a href="#day-3" class="headerlink" title="day 3"></a>day 3</h2><h3 id="number-of-atoms"><a href="#number-of-atoms" class="headerlink" title="number-of-atoms"></a>number-of-atoms</h3><pre><code>    利用栈和map来解析化学表达式，其中得注意字符和数字处理的API，使用java.util.*来处理排序（Arrays）</code></pre><h2 id="day-4"><a href="#day-4" class="headerlink" title="day 4"></a>day 4</h2><h3 id="asteroid-collision"><a href="#asteroid-collision" class="headerlink" title="asteroid-collision"></a>asteroid-collision</h3><pre><code>    利用一个栈来的特点来操作数据，而不是用两个栈</code></pre><h3 id="dailyTemperatures"><a href="#dailyTemperatures" class="headerlink" title="dailyTemperatures"></a>dailyTemperatures</h3><pre><code>    利用栈的特点来操作数据，比暴力解法要快得多</code></pre><h2 id="day-5"><a href="#day-5" class="headerlink" title="day 5"></a>day 5</h2><h3 id="backspace-string-compare"><a href="#backspace-string-compare" class="headerlink" title="backspace-string-compare"></a>backspace-string-compare</h3><pre><code> 利用栈的特点来操作数据</code></pre><h3 id="score-of-parentheses"><a href="#score-of-parentheses" class="headerlink" title="score-of-parentheses"></a>score-of-parentheses</h3><pre><code>    第一种比较容易想到的方法是利用栈来操作数据，类似于中缀表达式求值。（O(N),O(N)）    第二种方法：当仔细分析对结果有影响的因素时，会发现不同深度的()的得分会实质性地作用于最终的得分，其他的括号要么是累加，要么是将分数乘以2。进一步抽象，会发现2^x求和（x为()的深度）会是最终的结果（如果输入只有括号）。此时，并没有采用栈，而是发现了求最后结果的过程中，抽象出了数学表达式，利用数学表达式来求最后的结果。(O(N),O(1))    第三种方法：采用分治策略，组成最后的分的结果的要素分别相加求和。以平衡括号为字符串分解的点，若以左括号为1，右括号为-1，当遍历字符串时，S累加为0时，则说明有平衡括号()。(O(N^2),O(1))</code></pre><h3 id="decoded-string-at-index"><a href="#decoded-string-at-index" class="headerlink" title="decoded-string-at-index"></a>decoded-string-at-index</h3><pre><code>在影响最后结果的因素中，求出字符串结果不是必要的，反而，求出字符串变化后的size，能够实质性地助力求解最后地结果。另一方面，在字符串变化的过程中，仔细观察，会发现，当节码字符串长度为size的词重复多次时，索引K的结果与K/size的结果一致。正是这两个特点，就能够对暴力解法在时间复杂度或空间复杂度上作优化。这也是一例没有采用栈结构来求解的方法，直接运用求值过程中良好的特点来优化求值过程。（O(N),O(1)）</code></pre><h3 id="maximum-frequency-stack"><a href="#maximum-frequency-stack" class="headerlink" title="maximum-frequency-stack"></a>maximum-frequency-stack</h3><pre><code>官方代码其中一行：group.computeIfAbsent(f, z-&gt; new Stack()).push(x);(O(1),O(N))</code></pre><h3 id="online-stock-span"><a href="#online-stock-span" class="headerlink" title="online-stock-span"></a>online-stock-span</h3><pre><code>单调栈（栈中的数据非严格单调递减）求出小于或等于今天价格的最大连续日数等价于求出最近的一个大于今日价格的日子（O（N）,O(N)）</code></pre><h3 id="sum-of-subarray-minimums"><a href="#sum-of-subarray-minimums" class="headerlink" title="sum-of-subarray-minimums"></a>sum-of-subarray-minimums</h3><pre><code>    思路一：所有满足 `A[j]` 为最右且最小的元素的子序列个数 `#(j)`，那么结果就是 `sum #(j) * A[j]`.（O(N),O(N)）    [c++ 单调栈](https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/cdan-diao-zhan-by-qwqcxh/)    思路二：想法是每当我们增加 `j`，这些最小值可能会有关联，事实上，`min(A[i:j+1]) = min(A[i:j], A[j+1])`。采用栈的数据结构。（O(N),O(N)）    动态规划：    暴力解法：</code></pre><h3 id="odd-even-jump"><a href="#odd-even-jump" class="headerlink" title="odd-even-jump"></a>odd-even-jump</h3><h3 id="check-if-word-is-valid-after-substitutions"><a href="#check-if-word-is-valid-after-substitutions" class="headerlink" title="check-if-word-is-valid-after-substitutions"></a>check-if-word-is-valid-after-substitutions</h3><pre><code>class Solution {     public boolean isValid(String S) {         while(S.contains(&quot;abc&quot;)) {          S = S.replaceAll(&quot;abc&quot;,&quot;&quot;);          }     return S.equals(&quot;&quot;);     } }</code></pre><h3 id="next-greater-node-in-linked-list"><a href="#next-greater-node-in-linked-list" class="headerlink" title="next-greater-node-in-linked-list"></a>next-greater-node-in-linked-list</h3><pre><code>采用单调栈暴力解法[单调栈解法的其他题目](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/solution/python-dan-diao-zhan-by-jackwener/)</code></pre><h2 id="day-6"><a href="#day-6" class="headerlink" title="day 6"></a>day 6</h2><h3 id="longest-well-performing-interval"><a href="#longest-well-performing-interval" class="headerlink" title="longest-well-performing-interval"></a>longest-well-performing-interval</h3><pre><code>这个题目等下做</code></pre>]]></content>
      
      
      <categories>
          
          <category> 每日算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github/gitee/gitlab+optimization</title>
      <link href="/65248.html"/>
      <url>/65248.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="Hexo-GitHub"><a href="#Hexo-GitHub" class="headerlink" title="Hexo+GitHub"></a>Hexo+GitHub</h3><p>1.<a href="https://juejin.im/post/5dd2e898e51d45400206a466" target="_blank" rel="noopener">juejin.im/post/5dd2e898e51d45400206a466</a><br>2.<a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">godweiyang.com/2018/04/13/hexo-blog/</a><br>3.<a href="https://blog.sky03.cn/posts/41882.html" target="_blank" rel="noopener">blog.sky03.cn/posts/41882.html</a><br>4.<a href="https://www.cnblogs.com/bndong/p/9947729.html" target="_blank" rel="noopener">www.cnblogs.com/bndong/p/9947729.html</a><br>hexo+gitlab、hexo+gitee类似</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>1.<a href="https://blog.sky03.cn/posts/42790.html#toc-heading-15" target="_blank" rel="noopener">blog.sky03.cn/posts/42790.html#toc-heading-15</a><br>2.<a href="https://www.jianshu.com/p/a664545f155c" target="_blank" rel="noopener">jianshu.com/p/a664545f155c</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo文档</a><br>2.<a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">MarkDown文档</a></p><h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><p><a href="https://blog.csdn.net/banjw_129/article/details/82261165" target="_blank" rel="noopener">hexo +gitee pages 样式无法加载</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tool</title>
      <link href="/61453.html"/>
      <url>/61453.html</url>
      
        <content type="html"><![CDATA[<h2 id="语言文档"><a href="#语言文档" class="headerlink" title="语言文档"></a>语言文档</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.zealdocs.org" target="_blank" rel="noopener">Zeal</a> ：脱机文档       浏览器，包含196中语言API文档，支持Windows、Linux和macOS<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://zealusercontributions.now.sh/" target="_blank" rel="noopener">Zeal-docsets-xml</a> ：zeal 的docsets，采用xml引入<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.kapeli.com" target="_blank" rel="noopener">Dash</a>：适用于Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.devdocs.com" target="_blank" rel="noopener">DevDocs</a>：    在快速，有条理和可搜索的界面中结合许多个API文档，可以在移动设备上离线运行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://en.cppreference.com/w" target="_blank" rel="noopener">C/C++</a>：C/C++ API文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://docs.oracle.com/en/java" target="_blank" rel="noopener">Java</a>：Java API文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://lingcoder.github.io/OnJava8/#/" target="_blank" rel="noopener">On Java 8</a>：JAVA编程思想第五版（On Java 8）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://studygolang.com/pkgdoc" target="_blank" rel="noopener">Go</a>：Go API 文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://ww2.mathowrks.cn/help/matlab/index.html" target="_blank" rel="noopener">MATLAB</a>：MATLAB API 文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank" rel="noopener">HTML</a>：HTML API 文档<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://redisdoc.com" target="_blank" rel="noopener">Redis</a>：Redis API 文档</p><h2 id="在线平台"><a href="#在线平台" class="headerlink" title="在线平台"></a>在线平台</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://leetcode-cn.com/" target="_blank" rel="noopener">Leetcode</a>：算法练习等，编程能力提升的加油站<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.topcoder.com/" target="_blank" rel="noopener">Topcoder</a>：程序竞赛网站，适合一些高端的或者搞ACM的，也会举办一些比赛<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.lintcode.com/" target="_blank" rel="noopener">Leetcode</a>：中文版的leetcode，编程能力提升的加油站<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://acmclub.cn/" target="_blank" rel="noopener">NEUQ OJ</a>：在线的判题平台<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.nowcoder.com/contestRoom" target="_blank" rel="noopener">牛客网</a>：IT题库、牛客热评、面经、内推码等</p><h2 id="高校OJ"><a href="#高校OJ" class="headerlink" title="高校OJ"></a>高校OJ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://poj.org/" target="_blank" rel="noopener">POJ</a>：北京大学程序在线评测系统</p><h2 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a>站长工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://tool.chinaz.com/" target="_blank" rel="noopener">站长工具</a>：SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://linshiyouxiang.net/" target="_blank" rel="noopener">临时邮箱</a>：匿名注册不常用的网站/论坛，保护隐私免骚扰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a>：SM 免费图床，每个文件最大支持 5MB<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://namebeta.com/" target="_blank" rel="noopener">NnameBeta</a>：国际域名搜索、域名注册、国别域名注册、域名比价等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.domcomp.com/" target="_blank" rel="noopener">Domcomp</a>：域名比价<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tool.lusongsong.com/seo/" target="_blank" rel="noopener">SEO 外链工具</a>：网站自动化宣传机器/免费的超级外链工具可批量增加外链<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接码平台</p><p>​            <a href="http://z-sms.com/" target="_blank" rel="noopener">http://z-sms.com/</a><br>​            <a href="https://yunduanxin.net" target="_blank" rel="noopener">https://yunduanxin.net</a><br>​            <a href="http://z-sms.com/" target="_blank" rel="noopener">http://z-sms.com/</a><br>​            <a href="https://www.becmd.com/" target="_blank" rel="noopener">https://www.becmd.com/</a><br>​            <a href="https://www.cnwml.com/" target="_blank" rel="noopener">https://www.cnwml.com/</a><br>​            <a href="http://www.z-sms.com/" target="_blank" rel="noopener">http://www.z-sms.com/</a><br>​            <a href="http://receivefreesms.com/" target="_blank" rel="noopener">http://receivefreesms.com/</a><br>​            <a href="https://www.yinsixiaohao.com/" target="_blank" rel="noopener">https://www.yinsixiaohao.com/</a><br>​            <a href="https://sms.bilulanlv.com" target="_blank" rel="noopener">https://sms.bilulanlv.com</a><br>​            <a href="http://www.pdflibr.com" target="_blank" rel="noopener">www.pdflibr.com</a><br>​            <a href="">smsonline.ga</a><br>​            <a href="">smsreceivefree.com</a><br>​            <a href="http://www.receive-sms-online.info" target="_blank" rel="noopener">www.receive-sms-online.info</a><br>​            <a href="">receiveasms.com</a><br>​            <a href="">receivefreesms.com</a><br>​            <a href="http://www.becmd.com" target="_blank" rel="noopener">www.becmd.com</a><br>​            <a href="">sms-online.co</a><br>​            <a href="https://sms.bilulanlv.com">https://sms.bilulanlv.com</a><br>​            <a href="https://www.receivingsms.com" target="_blank" rel="noopener">https://www.receivingsms.com</a><br>​            <a href="https://www.blacktel.io" target="_blank" rel="noopener">https://www.blacktel.io</a><br>​            <a href="http://www.spoofbox.com" target="_blank" rel="noopener">http://www.spoofbox.com</a><br>​            <a href="https://sms.ndtan.net" target="_blank" rel="noopener">https://sms.ndtan.net</a><br>​            <a href="http://onlinesim.ru" target="_blank" rel="noopener">http://onlinesim.ru</a><br>​            <a href="https://www.twilio.com" target="_blank" rel="noopener">https://www.twilio.com</a><br>​            <a href="https://www.pdflibr.com" target="_blank" rel="noopener">https://www.pdflibr.com</a><br>​            <a href="http://sms.sellaite.com" target="_blank" rel="noopener">http://sms.sellaite.com</a><br>​            <a href="http://receive-sms-online.com" target="_blank" rel="noopener">http://receive-sms-online.com</a><br>​            <a href="https://www.freeonlinephone.org" target="_blank" rel="noopener">https://www.freeonlinephone.org</a><br>​            <a href="https://www.receivesmsonline.net" target="_blank" rel="noopener">https://www.receivesmsonline.net</a><br>​            <a href="http://receivefreesms.com" target="_blank" rel="noopener">http://receivefreesms.com</a><br>​            <a href="https://receive-sms.com" target="_blank" rel="noopener">https://receive-sms.com</a><br>​            <a href="https://sms-online.co/receive-free-sms" target="_blank" rel="noopener">https://sms-online.co/receive-free-sms</a><br>​            <a href="https://smsnumbersonline.com" target="_blank" rel="noopener">https://smsnumbersonline.com</a><br>​            <a href="https://receive-a-sms.com" target="_blank" rel="noopener">https://receive-a-sms.com</a><br>​            <a href="https://www.receive-sms-online.info" target="_blank" rel="noopener">https://www.receive-sms-online.info</a><br>​            <a href="https://smsreceivefree.com" target="_blank" rel="noopener">https://smsreceivefree.com</a><br>​            <a href="https://www.laiduqu.com" target="_blank" rel="noopener">https://www.laiduqu.com</a><br>​            <a href="https://www.attackmen.com/" target="_blank" rel="noopener">https://www.attackmen.com/</a><br>​            <a href="https://shimo.im/docs/BQ6UHIDt9ekOQHyv" target="_blank" rel="noopener">https://shimo.im/docs/BQ6UHIDt9ekOQHyv</a></p><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tool.lu/" target="_blank" rel="noopener">Coder 工具箱</a>：站长工具、代码格式化、压缩、加密、解密、下载链接转换等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tool.oschina.net/" target="_blank" rel="noopener">在线工具 - OSCHINA.NET社区</a>：常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://tools.ly522.com/" target="_blank" rel="noopener">记磊工具箱</a>：Dns检测、CSS格式化、超级Ping、端口扫描等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://tool.mkblog.cn" target="_blank" rel="noopener">孟坤工具箱</a>：css一键美化、文本差异比较、代码高亮等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.planetb.ca/syntax-highlight-word" target="_blank" rel="noopener">Syntax Highlight</a>：Syntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://qiao.github.io/PathFinding.js/visual/" target="_blank" rel="noopener">动画展示——路径搜索算法</a>：Syntax Highlight Code In Word Documents，动画展示各种路径搜索算法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/justjavac/free-programming-books-zh_CN">编程类中文书籍</a>：Syntax Highlight Code In Word Documents，免费计算机编程类中文书籍<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.easeus.com/" target="_blank" rel="noopener">磁盘分区软件</a>：EaseUS Partition Master——磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间</p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.pdfdo.com/" target="_blank" rel="noopener">文件转换器</a>：在线文件转换工具<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://convertio.co" target="_blank" rel="noopener">Convertio</a>：在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cn.office-converter.com" target="_blank" rel="noopener">Office-Converter</a>：免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.uupoop.com" target="_blank" rel="noopener">PS</a>：在线PS</p><h2 id="设计素材"><a href="#设计素材" class="headerlink" title="设计素材"></a>设计素材</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">Iconfont</a>：阿里巴巴矢量图标库，有矢量图标下载、在线存储、格式转换等功能<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.flaticon.com/" target="_blank" rel="noopener">Flaticon</a>：海量扁平化免费的图标库<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://icons8.com/" target="_blank" rel="noopener">icons8</a>：独特系统平台风格、独特的web图标库以及音乐</p><h2 id="手机刷机"><a href="#手机刷机" class="headerlink" title="手机刷机"></a>手机刷机</h2><p>刷机工具：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猎人大师（淘宝）；OPPO售后解锁恢复专用软件包；<br>网站：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="www.rom100.com">万维网</a><br>对于近1-2年的新机型，可能一般的解锁工具不太行，像解oppo reno 的屏幕锁，要么售后，要么邮寄找人解锁</p><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亿寻（湖南版；标准版），速度是杠杠的<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chrome插件+IDM，平时下载一些热门资源，速度和亿寻差不多，就是配置稍微有点麻烦<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://bbs.vipfenxiang.com/thread-52542-1-1.html" target="_blank" rel="noopener">vip分享网</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“淘一下”，基本6元左右一个月<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;收费软件：速盘（按流量收费）；新极品(6.5元/月合租百度网盘超级会员账号);</p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>​        <a href="http://bbs.xiaobaipan.com/forum.php?mod=viewthread&tid=13576&extra=" target="_blank" rel="noopener">计算机书籍</a></p><p>​                </p><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.liuyao-blog.cn" target="_blank" rel="noopener">liuyao</a>：Box中有许多个人手机的工具<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://godweiyang.com/" target="_blank" rel="noopener">WeiYang</a>：NLP、算法分享<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://flyrie.top/2018/10/20/Pip_No_Attribute_Main/" target="_blank" rel="noopener">田间小路</a>：ML、DL</p><h2 id="Software-PJ"><a href="#Software-PJ" class="headerlink" title="Software-PJ"></a>Software-PJ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.chinapyg.com" target="_blank" rel="noopener">飘云阁</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://masuit.com/1230/history" target="_blank" rel="noopener">懒得勤快</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.gopojie.net/" target="_blank" rel="noopener">GoPoJie</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.haozi666.com/" target="_blank" rel="noopener">耗子修改</a><br>​        <a href="http://www.carrotchou.blog/" target="_blank" rel="noopener">胡萝卜周</a><br>​        <a href="https://www.ypojie.com/" target="_blank" rel="noopener">易破解</a><br>​        <a href="https://bbs.pediy.com/thread-13361.htm" target="_blank" rel="noopener">国外破解网站大全</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/16107.html"/>
      <url>/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
