<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="concurrency, huang"><meta name="description" content=""><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><script async src="https://www.googletagmanager.com/gtag/js?id="></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","")</script><title>concurrency | huang</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/libs/awesome/css/all.css"><link rel="stylesheet" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/libs/aos/aos.css"><link rel="stylesheet" href="/libs/animate/animate.min.css"><link rel="stylesheet" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/css/matery.css"><link rel="stylesheet" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="huang" type="application/atom+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">huang</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">huang</div><div class="logo-desc">Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/hyl2048" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/hyl2048" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/3.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">concurrency</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px}#toc-content .is-active-link{color:#42b983}#toc-content .is-active-link::before{background-color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><span class="chip bg-color">无标签</span></div></div><div class="col s5 right-align"></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2020-11-25</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><p>底层的并发功能与上层应用程序的并发语义之间并不存在一种简单的而只管的映射关系。为了解决在Java 底层机制与设计级策略之间的不匹配问题，我们给出了一组简化的并发程序编写规则。</p><p>设计规则和思维模式</p><h2 id="并发编程基础理论"><a href="#并发编程基础理论" class="headerlink" title="并发编程基础理论"></a>并发编程基础理论</h2><h3 id="并发简史"><a href="#并发简史" class="headerlink" title="并发简史"></a>并发简史</h3><h3 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h3><h3 id="线程带来的风险"><a href="#线程带来的风险" class="headerlink" title="线程带来的风险"></a>线程带来的风险</h3><h4 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h4><h4 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h4><p>​ 死锁、饥饿、活锁</p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><h3 id="线程无处不在"><a href="#线程无处不在" class="headerlink" title="线程无处不在"></a>线程无处不在</h3><p>待开发的程序有或者没有，开发时使用的框架会有使用多线程，基本上所有的java应用程序都会有。</p><hr><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>​ 编写线程安全的代码，核心在于要对状态访问操作进行管理，特别是对共现的和可变的状态的访问。</p><h4 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h4><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为。</p><p>无状态对象一定是线程安全的。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><h5 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h5><p>​ 由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，也就是竞态条件。</p><p>​ 竞态条件和数据竞争的区别</p><h5 id="延迟初始化中的竞态条件"><a href="#延迟初始化中的竞态条件" class="headerlink" title="延迟初始化中的竞态条件"></a>延迟初始化中的竞态条件</h5><h5 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h5><p>​ java.util.concurrent.atomic包中含有原子变量类，用于实现在数值和对象引用上的原子状态转换。</p><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><h5 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h5><h5 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h5><p>内置锁是可重入的</p><h4 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h4><h4 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h4><h3 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>访问某个共享且可变得变量时要求所有相册给在同一个锁上同步。</p><h5 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h5><h5 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h5><h5 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h5><h5 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h5><p>​ volatile变量是一种比sychronized关键字更轻量级的同步机制</p><p>当且仅当满足以下所有条件时，才应该使用volatile变量</p><h4 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h4><p>发布一个对象是指，使对象能够在当前作用域之外的代码中使用。</p><p>当某个不应该发布的对象被发布时，这种情况就被称为逸出</p><h5 id="安全的对象构造过程"><a href="#安全的对象构造过程" class="headerlink" title="安全的对象构造过程"></a>安全的对象构造过程</h5><p>在构造函数中注册一个事件监听器或启动线程，使用一个室友的构造函数和一个公共的工厂方法来防止this引用在构造过程中逸出</p><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>如果仅在单线程类范围数据，就不需要同步，这个技术被成为相册线程封闭。封闭技术应用于Swingy以及JDBC的Connection对象。</p><h5 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h5><p>维护线程封闭性的职责完全由程序实现来承担</p><p>使用单线程子系统的另一个原因是为了避免死锁</p><h5 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h5><h5 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h5><p>当某个频执行的操作西药一个临时对象，例如一个缓冲区，而同时又洗碗避免在每次执行时重新分配该临时对象，就可以使用这项技术。</p><p>在实现用用程序框架是大量使用了ThreadLocal.在EJB调用期间</p><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>不可变对象一定是线程安全的</p><h5 id="Final域"><a href="#Final域" class="headerlink" title="Final域"></a>Final域</h5><h5 id="使用Volatile类型来发布不可变对象"><a href="#使用Volatile类型来发布不可变对象" class="headerlink" title="使用Volatile类型来发布不可变对象"></a>使用Volatile类型来发布不可变对象</h5><h4 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h4><h5 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h5><h5 id="不可变对象于初始化安全性"><a href="#不可变对象于初始化安全性" class="headerlink" title="不可变对象于初始化安全性"></a>不可变对象于初始化安全性</h5><h5 id="安全发布的常用模式"><a href="#安全发布的常用模式" class="headerlink" title="安全发布的常用模式"></a>安全发布的常用模式</h5><p>​ 要安全地阿发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p><p>​ 在静态初始化函数中初始化一个对象引用；</p><p>​ 将对象地引用保存到volatile类型地域或者AtomicReferance对象中。</p><p>​ 将对象的引用保存到某个正确构造对象的final类型域中。</p><p>​ 将对象的引用保存到一个由锁保护的域中。</p><p>​ 线程安全库中的容器类提供了以下的安全发布保证：</p><p>​ 类库中的其他数据传递机制同样能实现安全发布。</p><h5 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h5><h5 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h5><h6 id="对象的发布需求取决于它的可变性"><a href="#对象的发布需求取决于它的可变性" class="headerlink" title="对象的发布需求取决于它的可变性"></a>对象的发布需求取决于它的可变性</h6><p>不可变对象可以通过任意机制来发布；</p><p>事实不可变对象必须通过安全方式来发布；</p><p>可边对象必须通过安全方式来发布，并且必须时是线程安全的或者由某个锁保护起来。</p><p>​</p><h5 id="安全地共享对象"><a href="#安全地共享对象" class="headerlink" title="安全地共享对象"></a>安全地共享对象</h5><p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p><ul><li><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li><li><strong>只读共享</strong>。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li><li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li><li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封闭在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li></ul><h3 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h3><h4 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h4><p>通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。</p><p>同步策略定义了如何在不违背对象的不变性条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程安全性与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。</p><p>在设计线程安全的类的过程中，需要包含以下三个基本要素：</p><ul><li>找出构成对象状态的所有变量</li><li>找出约束状态变量的不变性条件</li><li>建立对象状态的并发访问管理策略</li></ul><h5 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h5><p>​ 要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。</p><p>​ 如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性于与封装性。</p><h5 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h5><h5 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h5><p>垃圾回收机制使我们避免了如何处理所有权的问题。</p><p>为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么时线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。</p><h4 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h4><p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。</p><p>Java平台的类库中由很多线程封闭的示例，其中有些类的唯一用途就是将非线程安全的类转化为线程安全的类。</p><h5 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h5><p>私有锁和对象的内置锁</p><h5 id="示例：车辆追踪"><a href="#示例：车辆追踪" class="headerlink" title="示例：车辆追踪"></a>示例：车辆追踪</h5><h4 id="线程安全性委托"><a href="#线程安全性委托" class="headerlink" title="线程安全性委托"></a>线程安全性委托</h4><h5 id="示例：基于委托的车辆追踪"><a href="#示例：基于委托的车辆追踪" class="headerlink" title="示例：基于委托的车辆追踪"></a>示例：基于委托的车辆追踪</h5><h5 id="独立的状态变量"><a href="#独立的状态变量" class="headerlink" title="独立的状态变量"></a>独立的状态变量</h5><h5 id="当委托失效时"><a href="#当委托失效时" class="headerlink" title="当委托失效时"></a>当委托失效时</h5><h5 id="发布底层的状态变量"><a href="#发布底层的状态变量" class="headerlink" title="发布底层的状态变量"></a>发布底层的状态变量</h5><h5 id="示例：发布状态的车辆追踪器"><a href="#示例：发布状态的车辆追踪器" class="headerlink" title="示例：发布状态的车辆追踪器"></a>示例：发布状态的车辆追踪器</h5><h4 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h4><p>Java类库包含许多有用的“基础模块”类。通常，我们应该优先选择重用这些现有的类而不是创建新的类：重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。</p><h5 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h5><p>客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护客户代码。要使用客户端加锁，你必须知道对象X使用的是哪一个锁。</p><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><h5 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h5><h3 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h3><h4 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h4><p>同步容器类有Vector和Hashtable，由Collections.synchronizedXxx等工厂方法创建。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p><h5 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h5><p>通过客户端加锁来解决不可靠迭代问题，但要牺牲一些伸缩性。</p><h5 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h5><h5 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h5><p>容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样，containsAll、removeAll和retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出ConcurrentModificationException。</p><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><p>Java5.0提供了许多并发容器类来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种哈哈的代价是杨中国降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><h5 id="额外的原子Map操作"><a href="#额外的原子Map操作" class="headerlink" title="额外的原子Map操作"></a>额外的原子Map操作</h5><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><h4 id="阻塞队列和生产者—消费者模式"><a href="#阻塞队列和生产者—消费者模式" class="headerlink" title="阻塞队列和生产者—消费者模式"></a>阻塞队列和生产者—消费者模式</h4><p>一种常见的生产者-消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现呢这种模式。</p><p><strong>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</strong></p><h5 id="示例：桌面搜索"><a href="#示例：桌面搜索" class="headerlink" title="示例：桌面搜索"></a>示例：桌面搜索</h5><h5 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h5><h5 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h5><h4 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h4><h4 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h4><h5 id="闭锁-Latch"><a href="#闭锁-Latch" class="headerlink" title="闭锁-Latch"></a>闭锁-Latch</h5><p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会在改变状态，因此这扇门将永远保持打开的状态。</p><h5 id="Future-Task"><a href="#Future-Task" class="headerlink" title="Future Task"></a>Future Task</h5><h5 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量-Semaphore"></a>信号量-Semaphore</h5><p>semaphore可以用于实现资源池，例如数据库的连接池。</p><h5 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏-Barrier"></a>栅栏-Barrier</h5><p>栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议。</p><h4 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h4><p>简单的缓存可能会将性能瓶颈转变成可伸缩性瓶颈，即使缓存是用于提升单线程的性能。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>并发技巧</strong></p><ul><li><p>​ 可变状态是至关重要的。所有的并发问题都可以归结为如何协调对并发状态的访问。可边状态越少，就越容易确保线程安全性。</p></li><li><p>​ 尽量将域声明为final类型，除非需要它们是可变的。</p></li><li><p>​ 不可变对象一定是线程安全的。不可变对象能极大地降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制。</p></li><li><p>​ 封装有助于管理复杂性。在编写线程安全程序时，虽然可以将所有数据都保存至全局变量中，但是为什么要这样做。将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</p></li><li><p>​ 用锁来保护每个可变变量</p></li><li><p>​ 当保护同一个不变性条件的所有变量时，要使用一个锁。</p></li><li><p>​ 在执行复合操作期间，要持有锁</p></li><li><p>​ 如果虫多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。</p></li><li><p>​ 不要故作聪明地推断出不需要使用同步。</p></li><li><p>​ 在设计过程中考虑线程安全，或者在文档中明 确地指出它不是线程安全的。</p></li><li><p>​ 将同步策略文档化。</p></li></ul><h2 id="并发应用程序的构造理论"><a href="#并发应用程序的构造理论" class="headerlink" title="并发应用程序的构造理论"></a>并发应用程序的构造理论</h2><p>大多数并发应用程序都市围绕“任务执行”来构造的：任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的十五边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。</p><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><h4 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h4><h5 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h5><h5 id="显式地为任务创建线程"><a href="#显式地为任务创建线程" class="headerlink" title="显式地为任务创建线程"></a>显式地为任务创建线程</h5><h5 id="无限制创建线程的不足"><a href="#无限制创建线程的不足" class="headerlink" title="无限制创建线程的不足"></a>无限制创建线程的不足</h5><h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a><strong>Executor框架</strong></h4><h5 id="示例：基于Excutor的Web服务器"><a href="#示例：基于Excutor的Web服务器" class="headerlink" title="示例：基于Excutor的Web服务器"></a>示例：基于Excutor的Web服务器</h5><h5 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h5><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><h5 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h5><h5 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h5><h4 id="找出可利用的并行性"><a href="#找出可利用的并行性" class="headerlink" title="找出可利用的并行性"></a>找出可利用的并行性</h4><h5 id="示例：串行的页面渲染器"><a href="#示例：串行的页面渲染器" class="headerlink" title="示例：串行的页面渲染器"></a>示例：串行的页面渲染器</h5><h5 id="携带结果的任务Callable与Future"><a href="#携带结果的任务Callable与Future" class="headerlink" title="携带结果的任务Callable与Future"></a>携带结果的任务Callable与Future</h5><h5 id="示例：使用Futuren实现页面渲染器"><a href="#示例：使用Futuren实现页面渲染器" class="headerlink" title="示例：使用Futuren实现页面渲染器"></a>示例：使用Futuren实现页面渲染器</h5><h5 id="在异构任务并行化中存在的局限"><a href="#在异构任务并行化中存在的局限" class="headerlink" title="在异构任务并行化中存在的局限"></a>在异构任务并行化中存在的局限</h5><h5 id="CompletionService-Executor与BlockingQueue"><a href="#CompletionService-Executor与BlockingQueue" class="headerlink" title="CompletionService:Executor与BlockingQueue"></a>CompletionService:Executor与BlockingQueue</h5><h5 id="示例：使用CompletionService实现页面渲染器"><a href="#示例：使用CompletionService实现页面渲染器" class="headerlink" title="示例：使用CompletionService实现页面渲染器"></a>示例：使用CompletionService实现页面渲染器</h5><h5 id="为任务设置时限"><a href="#为任务设置时限" class="headerlink" title="为任务设置时限"></a>为任务设置时限</h5><h5 id="示例：旅行预订门户网站"><a href="#示例：旅行预订门户网站" class="headerlink" title="示例：旅行预订门户网站"></a>示例：旅行预订门户网站</h5><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过围绕任务执行设计应用程序，可以简化开发过程，并有助于实现并发。Executor框架将任务提交与执行策略解耦开来，同时还支持多种不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用Executor。要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。</p><h3 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h3><h4 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><h5 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h5><h5 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h5><h5 id="示例：计时运行"><a href="#示例：计时运行" class="headerlink" title="示例：计时运行"></a>示例：计时运行</h5><h5 id="通过Future来实现取消"><a href="#通过Future来实现取消" class="headerlink" title="通过Future来实现取消"></a>通过Future来实现取消</h5><h5 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h5><h5 id="采用newTaskFor来封装非标准的取消"><a href="#采用newTaskFor来封装非标准的取消" class="headerlink" title="采用newTaskFor来封装非标准的取消"></a>采用newTaskFor来封装非标准的取消</h5><h4 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h4><h5 id="示例：日志服务"><a href="#示例：日志服务" class="headerlink" title="示例：日志服务"></a>示例：日志服务</h5><h5 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h5><h5 id="“毒丸”对象"><a href="#“毒丸”对象" class="headerlink" title="“毒丸”对象"></a>“毒丸”对象</h5><h5 id="示例-只执行一次的服务"><a href="#示例-只执行一次的服务" class="headerlink" title="示例:只执行一次的服务"></a>示例:只执行一次的服务</h5><h5 id="shutdownNow的局限性"><a href="#shutdownNow的局限性" class="headerlink" title="shutdownNow的局限性"></a>shutdownNow的局限性</h5><h4 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h4><h5 id="未捕获异常的处理"><a href="#未捕获异常的处理" class="headerlink" title="未捕获异常的处理"></a>未捕获异常的处理</h5><h4 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h4><h5 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h5><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><h5 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h5><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加它们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消或者总结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用FutureTask和Executor框架，可以帮助我们构建可取消任务和服务。</p><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="在任务与执行策略之间的隐性耦合"><a href="#在任务与执行策略之间的隐性耦合" class="headerlink" title="在任务与执行策略之间的隐性耦合"></a>在任务与执行策略之间的隐性耦合</h4><h5 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h5><h5 id="运行时间较长的任务"><a href="#运行时间较长的任务" class="headerlink" title="运行时间较长的任务"></a>运行时间较长的任务</h5><h4 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h4><h4 id="配置TheadPoolExecutor"><a href="#配置TheadPoolExecutor" class="headerlink" title="配置TheadPoolExecutor"></a>配置TheadPoolExecutor</h4><h5 id="线程的创建与销毁"><a href="#线程的创建与销毁" class="headerlink" title="线程的创建与销毁"></a>线程的创建与销毁</h5><h5 id="管理队列任务"><a href="#管理队列任务" class="headerlink" title="管理队列任务"></a>管理队列任务</h5><h5 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h5><h5 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h5><h5 id="在调用构造函数后再定制ThreadPoolExecutork"><a href="#在调用构造函数后再定制ThreadPoolExecutork" class="headerlink" title="在调用构造函数后再定制ThreadPoolExecutork"></a>在调用构造函数后再定制ThreadPoolExecutork</h5><h4 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h4><h5 id="给线程池添加统计信息"><a href="#给线程池添加统计信息" class="headerlink" title="给线程池添加统计信息"></a>给线程池添加统计信息</h5><h5 id="递归算法的并行化"><a href="#递归算法的并行化" class="headerlink" title="递归算法的并行化"></a>递归算法的并行化</h5><h5 id="谜题框架"><a href="#谜题框架" class="headerlink" title="谜题框架"></a>谜题框架</h5><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>对于并发执行的任务，Executor框架是一种强大且灵活的框架。它提供了大量可调节的选项，例如创建线程和关闭线程的策略，处理队列任务的策略，处理过多任务的策略，并且提供了几个钩子方法来扩展它的行为。然而，与大多数功能强大的框架一样，其中有些设置参数并不能很好地工作，某些类型地任务需要特定的执行策略，而一些参数组合则可能产生奇怪的结果。</p><h2 id="并发编程的性能调优"><a href="#并发编程的性能调优" class="headerlink" title="并发编程的性能调优"></a>并发编程的性能调优</h2><h3 id="避免活跃性危险"><a href="#避免活跃性危险" class="headerlink" title="避免活跃性危险"></a>避免活跃性危险</h3><p>安全性与活跃性之间通常存在着某种制衡。我们使用加锁机制来确保线程安全，但是如果过度地使用加锁，则可能导致锁顺序死锁。同样，我们使用线程池和信号量来限制对资源的使用，但这些被限制地行为可能会导致资源死锁。Java应用程序无法从死锁诉说中恢复过来，因此在设计时一定要排那些些导致死锁出现的条件。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h5><h5 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h5><h5 id="在协作对象之间发生的死锁"><a href="#在协作对象之间发生的死锁" class="headerlink" title="在协作对象之间发生的死锁"></a>在协作对象之间发生的死锁</h5><h5 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h5><h5 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h5><h4 id="死锁的避免与诊断"><a href="#死锁的避免与诊断" class="headerlink" title="死锁的避免与诊断"></a>死锁的避免与诊断</h4><h5 id="支持定时的锁"><a href="#支持定时的锁" class="headerlink" title="支持定时的锁"></a>支持定时的锁</h5><h5 id="通过线程转储信息来分析死锁"><a href="#通过线程转储信息来分析死锁" class="headerlink" title="通过线程转储信息来分析死锁"></a>通过线程转储信息来分析死锁</h5><h4 id="其他活跃性危险"><a href="#其他活跃性危险" class="headerlink" title="其他活跃性危险"></a>其他活跃性危险</h4><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><h5 id="糟糕的响应"><a href="#糟糕的响应" class="headerlink" title="糟糕的响应"></a>糟糕的响应</h5><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了中止应用程序之外没有其他任何机制可以帮助从这种故障时恢复过来。最常见的活跃性故障就是锁顺序死锁。在设计时应该避免产生锁顺序死锁：确保线程在获取多个锁时采用一致的顺序。最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。</p><h3 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h3><p>线程的最主要目的是提高程序的运行性能。</p><h4 id="对性能的思考"><a href="#对性能的思考" class="headerlink" title="对性能的思考"></a>对性能的思考</h4><p>更有效地利用现有处理资源，以及在出现新的处理资源时使程序尽可能地利用这些新资源。</p><h5 id="性能与可伸缩性-1"><a href="#性能与可伸缩性-1" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h5><p>可伸缩性：当增加计算资源时（例如CPU、内存、存储容量或I/O带宽），程序的吞吐量或者处理能力相应地增加。</p><h5 id="评估各种性能权衡因素"><a href="#评估各种性能权衡因素" class="headerlink" title="评估各种性能权衡因素"></a>评估各种性能权衡因素</h5><h4 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h4><p>在所有并发程序中都包含一些串行部分</p><h5 id="示例：在各种框架中隐藏的串行部分"><a href="#示例：在各种框架中隐藏的串行部分" class="headerlink" title="示例：在各种框架中隐藏的串行部分"></a>示例：在各种框架中隐藏的串行部分</h5><h5 id="Amdahl定律的应用"><a href="#Amdahl定律的应用" class="headerlink" title="Amdahl定律的应用"></a>Amdahl定律的应用</h5><h4 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h4><h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><h5 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h5><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><h4 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h4><p>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。减少锁的竞争能够提高性能和可伸缩性。</p><p>有两个因素将影响在锁上发生竞争的可能性：锁的请求频率，以及每次持有该锁的时间。</p><p>有三种方式可以降低锁的竞争程度：减少锁的持有时间；降低锁的请求频率；使用带有协调机制的独占锁，这些机制允许更高的并发性。</p><h5 id="缩小锁的范围"><a href="#缩小锁的范围" class="headerlink" title="缩小锁的范围"></a>缩小锁的范围</h5><h5 id="减少锁的粒度"><a href="#减少锁的粒度" class="headerlink" title="减少锁的粒度"></a>减少锁的粒度</h5><p>降低线程请求锁地频率（从而减少发生竞争的可能性）。这可以通过锁分段和锁分解等技术来实现。</p><p>对竞争适中的锁进行分解时，实际上是把这些锁转变未非竞争锁，从而有效地提高性能和可伸缩性。</p><h5 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h5><h5 id="避免热点域"><a href="#避免热点域" class="headerlink" title="避免热点域"></a>避免热点域</h5><h5 id="一些替代独占锁的方法"><a href="#一些替代独占锁的方法" class="headerlink" title="一些替代独占锁的方法"></a>一些替代独占锁的方法</h5><p>并发容器、读写锁、不可变对象以及原子变量</p><h5 id="检测CPU利用率"><a href="#检测CPU利用率" class="headerlink" title="检测CPU利用率"></a>检测CPU利用率</h5><h5 id="向对象池说“不”"><a href="#向对象池说“不”" class="headerlink" title="向对象池说“不”"></a>向对象池说“不”</h5><h4 id="示例：比较Map的性能"><a href="#示例：比较Map的性能" class="headerlink" title="示例：比较Map的性能"></a>示例：比较Map的性能</h4><h5 id="减少上下文切换的开销"><a href="#减少上下文切换的开销" class="headerlink" title="减少上下文切换的开销"></a>减少上下文切换的开销</h5><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>由于使用线程常常是为了充分利用多个处理器的计算能力，因此在并发程序性能的讨论中，通常更多地将侧重点放在吞吐量和可伸缩性上，而不是服务时间。Amdahl定律告诉我们，程序的可伸缩性取决于在所有代码中必须被串行执行的代码的比例。因为Java程序中串行操作的主要来源是独占方式的资源锁，因此通常可以通过一i啊方式来提升可伸缩性：减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>由于使用线程常常是为了充分利用多个处理器的计算能力，因此在并发程序性能的讨论中，通常更多地将侧重店放在吞吐量和可伸缩性上，而不是服务时间。Amdahl定律告诉我们，程序地可伸缩性取决于在所有代码中必须被串行执行地代码比例。因为Java程序中串行操作地主要来源是独占方式地资源锁，因此通常可以通过以下方式来提升可伸缩性：减少锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞锁来代替独占锁。</p><h3 id="并发程序的测试"><a href="#并发程序的测试" class="headerlink" title="并发程序的测试"></a>并发程序的测试</h3><h2 id="并发编程的高级主题"><a href="#并发编程的高级主题" class="headerlink" title="并发编程的高级主题"></a>并发编程的高级主题</h2><h4 id="Lock和ReentrantLock"><a href="#Lock和ReentrantLock" class="headerlink" title="Lock和ReentrantLock"></a>Lock和ReentrantLock</h4><h5 id="轮询锁与定时锁"><a href="#轮询锁与定时锁" class="headerlink" title="轮询锁与定时锁"></a>轮询锁与定时锁</h5><h5 id="可中断的锁获取操作"><a href="#可中断的锁获取操作" class="headerlink" title="可中断的锁获取操作"></a>可中断的锁获取操作</h5><h5 id="非块结构的加锁"><a href="#非块结构的加锁" class="headerlink" title="非块结构的加锁"></a>非块结构的加锁</h5><h4 id="性能考虑因素"><a href="#性能考虑因素" class="headerlink" title="性能考虑因素"></a>性能考虑因素</h4><h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><h5 id="在synchronized和ReentrantLock之间进行选择"><a href="#在synchronized和ReentrantLock之间进行选择" class="headerlink" title="在synchronized和ReentrantLock之间进行选择"></a>在synchronized和ReentrantLock之间进行选择</h5><p>在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用ReentranLock，这些功包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用synchronized。</p><h4 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读-写锁"></a>读-写锁</h4><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>与内置锁相比，显示的Lock提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列有着更好的额控制。但ReentranLock不能完全替代synchronized，只有在synchronized无法忙着需求时，才应该使用它。</p><p>读-写锁允许多个读线程并发地访问被保护地对象，当范围以读取操作为主地数据结构时，它能提高程序地可伸缩性。</p><h3 id="构建自定义的同步工具"><a href="#构建自定义的同步工具" class="headerlink" title="构建自定义的同步工具"></a>构建自定义的同步工具</h3><h3 id="原子变量与非阻塞同步机制"><a href="#原子变量与非阻塞同步机制" class="headerlink" title="原子变量与非阻塞同步机制"></a>原子变量与非阻塞同步机制</h3><p>非阻塞算法在可伸缩性和活跃性上拥有巨大的优势。由于非主赛算法可以使读个线程咋竞争相同的数据时不会发生阻塞，因此他们在粒度更细的层次上进行协调，并且极大地减少调度开销。而且，在非阻塞算法中不存在死锁和其他活跃性问题</p><h4 id="锁的劣势"><a href="#锁的劣势" class="headerlink" title="锁的劣势"></a>锁的劣势</h4><h4 id="硬件对并发的支持"><a href="#硬件对并发的支持" class="headerlink" title="硬件对并发的支持"></a>硬件对并发的支持</h4><h5 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h5><h5 id="非阻塞的计数器"><a href="#非阻塞的计数器" class="headerlink" title="非阻塞的计数器"></a>非阻塞的计数器</h5><h5 id="JVM对CAS的支持"><a href="#JVM对CAS的支持" class="headerlink" title="JVM对CAS的支持"></a>JVM对CAS的支持</h5><h4 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h4><h5 id="原子变量是一种“更好的volatile”"><a href="#原子变量是一种“更好的volatile”" class="headerlink" title="原子变量是一种“更好的volatile”"></a>原子变量是一种“更好的volatile”</h5><h5 id="性能比较：锁与原子变量"><a href="#性能比较：锁与原子变量" class="headerlink" title="性能比较：锁与原子变量"></a>性能比较：锁与原子变量</h5><h4 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h4><p>如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。</p><h5 id="非阻塞的栈"><a href="#非阻塞的栈" class="headerlink" title="非阻塞的栈"></a>非阻塞的栈</h5><h5 id="非阻塞的链表"><a href="#非阻塞的链表" class="headerlink" title="非阻塞的链表"></a>非阻塞的链表</h5><h5 id="原子的域更新器"><a href="#原子的域更新器" class="headerlink" title="原子的域更新器"></a>原子的域更新器</h5><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>非阻塞算法通过底层的并发原语（例如比较交换而不是锁）来维持线程的安全性。这些底层的原语通过原子变量类向外公开，这些类也用作一种“更好的volatile”，从而为整数和对象引用提供原子的更新操作。</p><p>非阻塞算法在设计和实现时非常困难，但通常能够提供更高的可伸缩性，并能更好地防止活跃性故障的发生。在JVM从一个版本升级到下一个版本的过程中，并发性能的主要提升都来自于（在JVM内部以及平台类库中）对非阻塞算法的使用。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="什么是内存模型，为什么需要它"><a href="#什么是内存模型，为什么需要它" class="headerlink" title="什么是内存模型，为什么需要它"></a>什么是内存模型，为什么需要它</h4><h5 id="平台的内存模型"><a href="#平台的内存模型" class="headerlink" title="平台的内存模型"></a>平台的内存模型</h5><h5 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h5><h5 id="Java内存模型简介"><a href="#Java内存模型简介" class="headerlink" title="Java内存模型简介"></a>Java内存模型简介</h5><h5 id="借助同步"><a href="#借助同步" class="headerlink" title="借助同步"></a>借助同步</h5><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><h5 id="不安全的发布"><a href="#不安全的发布" class="headerlink" title="不安全的发布"></a>不安全的发布</h5><h5 id="安全的发布"><a href="#安全的发布" class="headerlink" title="安全的发布"></a>安全的发布</h5><h5 id="安全初始化模式"><a href="#安全初始化模式" class="headerlink" title="安全初始化模式"></a>安全初始化模式</h5><h5 id="双重检测加锁"><a href="#双重检测加锁" class="headerlink" title="双重检测加锁"></a>双重检测加锁</h5><h4 id="初始化过程中的安全性"><a href="#初始化过程中的安全性" class="headerlink" title="初始化过程中的安全性"></a>初始化过程中的安全性</h4><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>Java内存模型说明了某个线程的内存操作在哪些情况下对于其他线程是可见的。其中包括确保这些操作是按照一种Happens-before的偏序关系进行排序，而这种关系是基于内存操作和同步操作等级别来定义的。如果缺少重组的同步，那么当相册给访问共享数据时，会发生一些非常器官的额问题。然而，如果使用第2章与第3章介绍的更高级规则，例如@GuardedBy和安全发布，那么即使不考虑Hapens-Before的底层细节，也能确保线程安全性。</p><h2 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h2><p>Vector</p><p>其他同步集合类</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java 并发编程实践》机械工业出版社 2012.2</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="https://hyl2048.github.io" rel="external nofollow noreferrer">yulin</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://hyl2048.github.io/35296.html">https://hyl2048.github.io/35296.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="https://hyl2048.github.io" target="_blank">yulin</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><span class="chip bg-color">无标签</span></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><link rel="stylesheet" href="/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container" class="card-content"></div></div><script src="/libs/gitalk/gitalk.min.js"></script><script>let gitalk = new Gitalk({
        clientID: '9e23a93e6d565c5b255e',
        clientSecret: '3b42941e0d79049bad19fac40d7d0c1cae96edbe',
        repo: 'hyl2048.github.io',
        owner: 'hyl2048',
        admin: "hyl2048",
        id: '2020-11-25T01-23-10',
        distractionFreeMode: false,  // Facebook-like distraction free mode
		proxy: "https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token"
		
    });

    gitalk.render('gitalk-container');</script><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url("") 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"Q7ieo9PSWwtIK9dt4KyeSH0w-gzGzoHsz",appKey:"MEHtfyfhw8wH8P6tTgmu5Ag0",notify:!1,verify:!1,visitor:!0,avatar:"wavatar",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/54664.html"><div class="card-image"><img src="/medias/featureimages/15.jpg" class="responsive-img" alt="Spring-detail"> <span class="card-title">Spring-detail</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-11-25</span><span class="publish-author"><i class="fas fa-user fa-fw"></i> yulin</span></div></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/2018.html"><div class="card-image"><img src="/medias/featureimages/21.jpg" class="responsive-img" alt="sites-to-fork"> <span class="card-title">sites-to-fork</span></div></a><div class="card-content article-content"><div class="summary block-with-text">技术博客Haldir:前端|开发|系统|工具 美团技术团队 阿里中间件团队 Gityuan:Android相关的网址资料 renpingsheng: Redis详解 朱小斯 田小波 梁松华-京东高工 苏南-electron：electron</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-11-25</span><span class="publish-author"><i class="fas fa-user fa-fw"></i> yulin</span></div></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: huang<br />文章作者: yulin<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="/libs/codeBlock/codeBlockFuction.js"></script><script src="/libs/codeBlock/codeLang.js"></script><script src="/libs/codeBlock/codeCopy.js"></script><script src="/libs/codeBlock/codeShrink.js"></script><style>code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/libs/aplayer/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><div class="container row center-align"><div class="col s12 m8 l8 copy-right">&copy;huang. 版权所有 &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp; <span class="white-color">104.9k</span><br><span id="sitetime"></span><br><span id="busuanzi_container_site_pv" style="display:none"><i class="fa fa-heart-o"></i> 本站总访问量<span id="busuanzi_value_site_pv" class="white-color"></span></span> <span id="busuanzi_container_site_uv" style="display:none">人次,&nbsp;访客数<span id="busuanzi_value_site_uv" class="white-color"></span> 人.</span></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/hyl2048" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:qhuang724@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2745506937" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2745506937" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><script>$(document).ready(function(){var e=setInterval(function(){"none"!=document.getElementById("busuanzi_container_site_pv").style.display&&($("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html())+n),clearInterval(e));"none"!=$("#busuanzi_container_site_pv").css("display")&&($("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html())+t),clearInterval(e))},50),n=0,t=0})</script><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth()+1,n=o.getDate(),r=o.getHours(),l=o.getMinutes(),s=o.getSeconds(),M=Date.UTC(2020,3,28,0,0,0),g=Date.UTC(i,a,n,r,l,s)-M,m=Math.floor(g/31536e6),T=Math.floor(g/t-365*m),f=Math.floor((g-(365*m+T)*t)/e),h=Math.floor((g-(365*m+T)*t-f*e)/6e4),u=Math.floor((g-(365*m+T)*t-f*e-6e4*h)/1e3);document.getElementById("sitetime").innerHTML="本站已运行 "+m+" 年 "+T+" 天 "+f+" 小时 "+h+" 分钟 "+u+" 秒"}siteTime()</script><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script>$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script></body></html>